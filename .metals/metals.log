[0m2021.03.03 23:48:52 INFO  Started: Metals version 0.10.0 in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim' for client vscode 1.45.1.[0m
[0m2021.03.03 23:48:56 INFO  time: initialize in 3.52s[0m
[0m2021.03.03 23:49:01 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.03 23:49:01 ERROR org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.03 23:49:01 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.03 23:49:03 ERROR unable to setup persistent H2 database with AUTO_SERVER=false, falling back to in-memory database. This means you may be redundantly asked to execute 'Import build', even if it's not needed. Also, code navigation will not work for existing files in the .metals/readonly/ directory. To fix this problem, make sure you only have one running Metals server in the directory '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'.
org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.03 23:49:04 WARN  Build server is not auto-connectable.[0m
[0m2021.03.03 23:49:05 WARN  no build tool detected in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.03 23:49:05 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/memory/cache/mainMemWrapper.scala[0m
[0m2021.03.03 23:49:06 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/memory/cache/Routine.scala[0m
[0m2021.03.03 23:49:06 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/memory/cache/nextRoutine.scala[0m
[0m2021.03.03 23:49:08 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/config/Configs.scala[0m
[0m2021.03.03 23:49:08 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/message/messageType.scala[0m
[0m2021.03.03 23:49:09 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/interfaces/CostumInterface.scala[0m
[0m2021.03.03 23:49:09 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/interfaces/interfaces.scala[0m
[0m2021.03.03 23:49:10 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
[0m2021.03.03 23:49:10 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/shell/DCR.scala[0m
[0m2021.03.03 23:49:11 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
[0m2021.03.03 23:49:11 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/memory/cache/cacheNode.scala[0m
[0m2021.03.03 23:49:11 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/memory/cache/programmableCache.scala[0m
[0m2021.03.03 23:49:12 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/DandelionShell.scala[0m
[0m2021.03.03 23:49:12 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
[0m2021.03.03 23:49:13 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/build.sbt[0m
package memGen.memory.cache

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.util._
import memGen.interfaces._
import memGen.interfaces.axi._
import memGen.memory.message._
import chisel3.util.experimental.loadMemoryFromFile
import memGen.junctions._
import memGen.shell._



class memoryWrapperIO (implicit val p:Parameters) extends Bundle
with HasAccelShellParams
with HasCacheAccelParams {

    val in = Flipped(Decoupled( new IntraNodeBundle()))
    val mem = new AXIMaster(memParams)
    val out = Valid(new IntraNodeBundle())

//    mem.tieoff()

}

class memoryWrapper ()(implicit val p:Parameters) extends Module
with HasCacheAccelParams
with HasAccelShellParams{
    val io = IO(new memoryWrapperIO)

    val addrReg = RegInit(0.U(addrLen.W))
    val dataRegRead = RegInit(VecInit(Seq.fill(nData)(0.U(xlen.W))))
    val dataRegWrite = RegInit(VecInit(Seq.fill(nData)(0.U(xlen.W))))
    val (rd :: wr_back :: Nil ) = Enum(2)
    val (stIdle :: stWriteAddr :: stWriteData :: stReadAddr :: stReadData :: stCmdIssue :: Nil) = Enum(6)
    val stReg = RegInit(stIdle)

    val start = Wire(Bool())
    start := io.in.fire() & stReg === stIdle & io.in.bits.addr =/= 0.U

    when (start){
        addrReg := io.in.bits.addr
    }


    io.in.ready := stReg === stIdle

    val writeInst = WireInit(start & io.in.bits.inst === wr_back)

    // Reading
    val (readCount, readWrapped) = Counter (io.mem.r.fire(), nData)
    val (writeCount, writeWrapped) = Counter(io.mem.w.fire(), nData)


    when(writeInst){
        dataRegWrite := io.in.bits.data.asTypeOf(Vec(nData, UInt(xlen.W)))
    }

    when(io.mem.r.fire()) {
        dataRegRead(readCount) := io.mem.r.bits.data
    }
// 
    // val lenBits = 64.U
    io.mem.aw.bits.addr := Mux(stReg === stWriteAddr, addrReg, 0.U(addrLen.W))
    io.mem.aw.bits.len := nData.U

    io.mem.w.bits.data := Mux(stReg === stWriteData, dataRegWrite(writeCount), 0.U(xlen.W))
    io.mem.w.bits.last := false.B

    io.mem.ar.bits.addr := addrReg
    io.mem.ar.bits.len := nData.U - 1.U
    io.mem.b.ready := stReg === stWriteData

    io.mem.ar.valid := false.B
    io.mem.aw.valid := false.B
    io.mem.r.ready := false.B
    io.mem.w.valid := false.B

    val issueCmd = Wire(Bool())
    issueCmd := false.B


    io.out.bits.data := Cat(dataRegRead)
    io.out.bits.addr := addrReg
    io.out.bits.inst := Events.EventArray("DATA").U
    io.out.valid := false.B
    

    printf(p"data Reg ${dataRegRead} \n")
        printf(p"st Reg ${stReg} \n")


    switch(stReg){
        is(stIdle){
            when (start){
                when(writeInst){
                    stReg := stWriteAddr
                }.otherwise{
                    stReg := stReadAddr
                }
            }
        }
        is(stReadAddr){
            io.mem.ar.valid := true.B
            when(io.mem.ar.fire()){
                stReg := stReadData
            }
        }
        is(stReadData) {
            io.mem.r.ready := true.B
            when(io.mem.r.fire() && io.mem.r.bits.last) {
                stReg := stCmdIssue
            }
        }
        is(stWriteAddr){
            io.mem.aw.valid := true.B
            when(io.mem.aw.fire()){
                stReg := stWriteData
            }
        }
        is (stWriteData){
            io.mem.w.valid := true.B
            when(writeWrapped){
                stReg := stIdle
            }
        }
        is(stCmdIssue){
            io.out.valid := true.B
            stReg := stIdle
        }
    }

    io.mem.setConst()


}

import sbt.complete._
import sbt.complete.DefaultParsers._
import xerial.sbt.pack._
import sys.process._

enablePlugins(PackPlugin)

lazy val commonSettings = Seq(
  organization := "edu.sfu.cs",
  name := "dandelion-sim",
  version      := "1.0-SNAPSHOT",
  scalaVersion := "2.12.10",
  parallelExecution in Global := false,
  logBuffered in Test := false,
  testOptions in Test += Tests.Argument("-oDS"),
  traceLevel   := 15,
  scalacOptions ++= Seq("-deprecation","-unchecked","-Xsource:2.11"),
  libraryDependencies ++= Seq("org.scala-lang" % "scala-reflect" % scalaVersion.value),
  addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0" cross CrossVersion.full),
  resolvers ++= Seq(
    Resolver.sonatypeRepo("snapshots"),
    Resolver.sonatypeRepo("releases"),
    Resolver.mavenLocal
  )
)

// lazy val chisel = (project in file("chisel3")).settings(commonSettings)

def dependOnChisel(prj: Project) = {
  prj.settings(
    libraryDependencies ++= Seq("edu.berkeley.cs" %% "chisel3" % "3.3-SNAPSHOT")
  )
}

lazy val `api-config-chipsalliance` = (project in file("api-config-chipsalliance/build-rules/sbt"))
  .settings(commonSettings)
  .settings(publishArtifact := false)

lazy val dandelion = dependOnChisel(project).settings(commonSettings)
  .settings(publishArtifact := false)

lazy val `memGen` = (project in file("memGen"))
  .settings(commonSettings)
  .settings(publishArtifact := false)

lazy val `dandelionsim` = dependOnChisel(project in file("."))
  .settings(commonSettings, chipSettings)
  .dependsOn(`api-config-chipsalliance` % "compile-internal;test-internal")
  .dependsOn(dandelion % "compile-internal;test-internal")
  .dependsOn(`memGen` % "compile-internal;test-internal")
  .settings(
    aggregate := false,
    // Include macro classes, resources, and sources in main jar.
    mappings in (Compile, packageBin) ++= (mappings in (`api-config-chipsalliance`, Compile, packageBin)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`api-config-chipsalliance`, Compile, packageSrc)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`memGen`, Compile, packageSrc)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`memGen`, Compile, packageSrc)).value,
    mappings in (Compile, packageBin) ++= (mappings in (dandelion, Compile, packageBin)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (dandelion, Compile, packageSrc)).value,
    exportJars := true
  )

lazy val addons = settingKey[Seq[String]]("list of addons used for this build")
lazy val make = inputKey[Unit]("trigger backend-specific makefile command")
val setMake = NotSpace ~ ( Space ~> NotSpace )

lazy val chipSettings = Seq(
  addons := {
    val a = sys.env.getOrElse("DANDELION_ADDONS", "")
    println(s"Using addons: $a")
    a.split(" ")
  },
  unmanagedSourceDirectories in Compile ++= addons.value.map(baseDirectory.value / _ / "src/main/scala"),
  mainClass in (Compile, run) := Some("dandelionsim.Generator"),
  make := {
    val jobs = java.lang.Runtime.getRuntime.availableProcessors
    val (makeDir, target) = setMake.parsed
    (run in Compile).evaluated
    s"make -C $makeDir  -j $jobs $target".!
  }
)


package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._

/** Register File.
 *
 * Six 32-bit register file.
 *
 * -------------------------------
 * Register description    | addr
 * -------------------------|-----
 * Control status register | 0x00
 * Cycle counter           | 0x04
 * Constant value          | 0x08
 * Vector length           | 0x0c
 * Input pointer lsb       | 0x10
 * Input pointer msb       | 0x14
 * Output pointer lsb      | 0x18
 * Output pointer msb      | 0x1c
 * -------------------------------
 *
 * ------------------------------
 * Control status register | bit
 * ------------------------------
 * Launch                  | 0
 * Finish                  | 1
 * ------------------------------
 */


/*
+------------------+                          +-----------------+
|                  | f(bits)+--------+        |                 |
|   DMEReadMaster  +------->+Buffers +-------->DMEWriteMaster   |
|                  |        +--------+        |                 |
+------------------+                          +-----------------+

 */

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */

/**
 *
 * @param p
 */
class DandelionVTAShell(implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val vcr = Module(new DCR)
  val dmem = Module(new DME)

  val buffer = Module(new Queue(dmem.io.dme.rd(0).data.bits.cloneType, 40))

  val sIdle :: sReq :: sBusy :: Nil = Enum(3)
  val Rstate = RegInit(sIdle)
  val Wstate = RegInit(sIdle)

  val cycle_count = new Counter(2000)

  when(Rstate =/= sIdle) {
    cycle_count.inc()
  }


  vcr.io.dcr.ecnt(0.U).bits := cycle_count.value

  // Read state machine
  switch(Rstate) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        cycle_count.value := 0.U
        Rstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.rd(0).cmd.fire()) {
        Rstate := sBusy
      }
    }
  }
  // Write state machine
  switch(Wstate) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        Wstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.wr(0).cmd.fire()) {
        Wstate := sBusy
      }
    }
  }

  dmem.io.dme.rd(0).cmd.bits.addr := vcr.io.dcr.ptrs(0)
  dmem.io.dme.rd(0).cmd.bits.len := vcr.io.dcr.vals(1)
  dmem.io.dme.rd(0).cmd.valid := false.B

  dmem.io.dme.wr(0).cmd.bits.addr := vcr.io.dcr.ptrs(2)
  dmem.io.dme.wr(0).cmd.bits.len := vcr.io.dcr.vals(1)
  dmem.io.dme.wr(0).cmd.valid := false.B

  when(Rstate === sReq) {
    dmem.io.dme.rd(0).cmd.valid := true.B
  }

  when(Wstate === sReq) {
    dmem.io.dme.wr(0).cmd.valid := true.B
  }

  // Final
  val last = Wstate === sBusy && dmem.io.dme.wr(0).ack
  vcr.io.dcr.finish := last
  vcr.io.dcr.ecnt(0).valid := last

  when(dmem.io.dme.wr(0).ack) {
    Rstate := sIdle
    Wstate := sIdle
  }


  buffer.io.enq <> dmem.io.dme.rd(0).data
  buffer.io.enq.bits := dmem.io.dme.rd(0).data.bits + vcr.io.dcr.vals(0)
  dmem.io.dme.wr(0).data <> buffer.io.deq

  io.mem <> dmem.io.mem
  io.host <> vcr.io.host

}

class DandelionF1DTAShell(implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new ConfigBusMaster(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val dcr = Module(new DCRF1)
  val dmem = Module(new DME)

  val buffer = Module(new Queue(dmem.io.dme.rd(0).data.bits.cloneType, 40))

  val sIdle :: sReq :: sBusy :: Nil = Enum(3)
  val Rstate = RegInit(sIdle)
  val Wstate = RegInit(sIdle)

  val cycle_count = new Counter(2000)

  when(Rstate =/= sIdle) {
    cycle_count.inc()
  }


  dcr.io.dcr.ecnt(0.U).bits := cycle_count.value

  // Read state machine
  switch(Rstate) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        cycle_count.value := 0.U
        Rstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.rd(0).cmd.fire()) {
        Rstate := sBusy
      }
    }
  }
  // Write state machine
  switch(Wstate) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        Wstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.wr(0).cmd.fire()) {
        Wstate := sBusy
      }
    }
  }

  dmem.io.dme.rd(0).cmd.bits.addr := dcr.io.dcr.ptrs(0)
  dmem.io.dme.rd(0).cmd.bits.len := dcr.io.dcr.vals(1)
  dmem.io.dme.rd(0).cmd.valid := false.B

  dmem.io.dme.wr(0).cmd.bits.addr := dcr.io.dcr.ptrs(1)
  dmem.io.dme.wr(0).cmd.bits.len := dcr.io.dcr.vals(1)
  dmem.io.dme.wr(0).cmd.valid := false.B

  when(Rstate === sReq) {
    dmem.io.dme.rd(0).cmd.valid := true.B
  }

  when(Wstate === sReq) {
    dmem.io.dme.wr(0).cmd.valid := true.B
  }

  // Final
  val last = Wstate === sBusy && dmem.io.dme.wr(0).ack
  dcr.io.dcr.finish := last
  dcr.io.dcr.ecnt(0).valid := last

  when(dmem.io.dme.wr(0).ack) {
    Rstate := sIdle
    Wstate := sIdle
  }


  buffer.io.enq <> dmem.io.dme.rd(0).data
  buffer.io.enq.bits := dmem.io.dme.rd(0).data.bits + dcr.io.dcr.vals(0)
  dmem.io.dme.wr(0).data <> buffer.io.deq

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

}

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionCacheShell[T <: DandelionAccelModule](accelModule: () => T)
                                                    (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                    (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  //val cache = Module(new SimpleCache(debug = true))
  val cache = Module(new ReferenceCache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.Returns.size > 0) {
    for (i <- 1 to accel.Returns.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- numPtrs until numPtrs + numVals) {
    accel.io.in.bits.data(s"field${i}") := DataBundle(ptrs(i))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := state === sFlush

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  io.mem <> cache.io.mem
  io.host <> vcr.io.host

}


/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionDCRCacheShell[T <: DandelionAccelDCRModule](accelModule: () => T)
                                                          (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                          (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  //val cache = Module(new SimpleCache(debug = true))
  val cache = Module(new ReferenceCache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }
  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i - numPtrs))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := false.B

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      cache.io.cpu.flush := true.B
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  io.mem <> cache.io.mem
  io.host <> vcr.io.host

}

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionDCRShell[T <: DandelionAccelDCRModule](accelModule: () => T)
                                                     (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                     (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  val dme = Module(new DME)
  val cache = Module(new DMECache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }
  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i - numPtrs))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := state === sFlush

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  //io.mem <> cache.io.mem

  dme.io.dme.rd(0) <> cache.io.mem.rd
  dme.io.dme.wr(0) <> cache.io.mem.wr

  io.mem <> dme.io.mem
  io.host <> vcr.io.host

}


/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input ptrs for the accelerator
 * @param numVals     Number of input values to the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 */
class DandelionDebugShell(accelModule: () => DandelionAccelDCRModule)
                         (debugModule: () => DandelionAccelDebugModule)
                         (numPtrs: Int, numDbgs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                         (implicit val p: Parameters) extends Module with HasAccelParams with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits

  /**
   * If xlen is 64bit, and vcr registers are 32bits then
   * ptrs are lo and hi
   */
  val ptrBits =
    if (xlen / regBits == 2)
      regBits * 2
    else
      regBits


  val dcr = Module(new DCR)
  val dmem = Module(new DME())
  val cache = Module(new DMECache())


  val accel = Module(accelModule())
  def isDebugger() = { numDbgs > 0}
  val debug_module = if (numDbgs > 0) Some(Module(debugModule())) else None

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp
  cache.io.cpu.abort := false.B

  /**
   * Connecting cache to DME
   */
  dmem.io.dme.rd(0) <> cache.io.mem.rd
  dmem.io.dme.wr(0) <> cache.io.mem.wr

  /**
   * TODO: make enable dependent on logic
   */
  if(isDebugger()) debug_module.get.io.enableNode.foreach(_ := true.B)

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  dcr.io.dcr.ecnt(0).valid := last
  dcr.io.dcr.ecnt(0).bits := cycles

  for (i <- 1 to numRets) {
    dcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
    dcr.io.dcr.ecnt(i).valid := accel.io.out.valid
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs + numDbgs) { i => RegEnable(next = dcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = dcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  /**
   * For now the rule is to first assign the pointers and then assign the vals
   */

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }

  /**
   * Connecting debug ptrs
   */
  for (i <- 0 until numDbgs) {
    debug_module.get.io.addrDebug(i) := dcr.io.dcr.ptrs(numPtrs + i)
  }


  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i))
  }


  accel.io.in.bits.enable := ControlBundle.debug()

  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.flush := state === sFlush

  for (i <- 0 until numDbgs) {
    dmem.io.dme.wr(i + 1).cmd.bits := debug_module.get.io.vmeOut(i).cmd.bits
    dmem.io.dme.wr(i + 1).cmd.valid := debug_module.get.io.vmeOut(i).cmd.valid
    debug_module.get.io.vmeOut(i).cmd.ready := dmem.io.dme.wr(i + 1).cmd.ready

    dmem.io.dme.wr(i + 1).data <> debug_module.get.io.vmeOut(i).data
    debug_module.get.io.vmeOut(i).ack := dmem.io.dme.wr(i + 1).ack
  }

  val dme_ack = if(isDebugger()) Some(RegInit(VecInit(Seq.fill(numDbgs)(false.B)))) else None
  for (i <- 0 until numDbgs) {
    when(dmem.io.dme.wr(i + 1).ack) {
      dme_ack.get(i) := true.B
    }
  }

  def isDMEAck(): Bool = {
    if (numDbgs == 0)
      true.B
    else {
      dme_ack.get.reduceLeft(_ && _)
    }
  }

  val cache_done = RegInit(false.B)
  when(state === sFlush) {
    when(cache.io.cpu.flush_done) {
      cache_done := true.B
    }
  }

  switch(state) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): 0x${Hexadecimal(t._1)}, "))
        printf(p"\nVals: ")
        if (numVals > 0) {
          vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): 0x${Hexadecimal(t._1)}, "))
        } else {
          printf("N/A")
        }
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache_done && isDMEAck()) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  dcr.io.dcr.finish := last

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

}


/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input ptrs for the accelerator
 * @param numVals     Number of input values to the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 */
class DandelionDebugFPGAShell(accelModule: () => DandelionAccelDCRModule)
                         (debugModule: () => DandelionAccelDebugModule)
                         (numPtrs: Int, numDbgs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                         (implicit val p: Parameters) extends Module with HasAccelParams with HasAccelShellParams {
  val io = IO(new Bundle {
//    val host = new AXIClient(hostParams)
    val host = new ConfigBusMaster(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits

  /**
   * If xlen is 64bit, and vcr registers are 32bits then
   * ptrs are lo and hi
   */
  val ptrBits =
    if (xlen / regBits == 2)
      regBits * 2
    else
      regBits


//  val dcr = Module(new DCR)
  val dcr = Module(new DCRF1)
  val dmem = Module(new DME())
  val cache = Module(new DMECache())


  val accel = Module(accelModule())
  def isDebugger() = { numDbgs > 0}
  val debug_module = if (numDbgs > 0) Some(Module(debugModule())) else None

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp
  cache.io.cpu.abort := false.B

  /**
   * Connecting cache to DME
   */
  dmem.io.dme.rd(0) <> cache.io.mem.rd
  dmem.io.dme.wr(0) <> cache.io.mem.wr

  /**
   * TODO: make enable dependent on logic
   */
  if(isDebugger()) debug_module.get.io.enableNode.foreach(_ := true.B)

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  dcr.io.dcr.ecnt(0).valid := last
  dcr.io.dcr.ecnt(0).bits := cycles

  for (i <- 1 to numRets) {
    dcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
    dcr.io.dcr.ecnt(i).valid := accel.io.out.valid
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs + numDbgs) { i => RegEnable(next = dcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = dcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  /**
   * For now the rule is to first assign the pointers and then assign the vals
   */

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }

  /**
   * Connecting debug ptrs
   */
  for (i <- 0 until numDbgs) {
    debug_module.get.io.addrDebug(i) := dcr.io.dcr.ptrs(numPtrs + i)
  }


  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i))
  }


  accel.io.in.bits.enable := ControlBundle.debug()

  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.flush := state === sFlush

  for (i <- 0 until numDbgs) {
    dmem.io.dme.wr(i + 1).cmd.bits := debug_module.get.io.vmeOut(i).cmd.bits
    dmem.io.dme.wr(i + 1).cmd.valid := debug_module.get.io.vmeOut(i).cmd.valid
    debug_module.get.io.vmeOut(i).cmd.ready := dmem.io.dme.wr(i + 1).cmd.ready

    dmem.io.dme.wr(i + 1).data <> debug_module.get.io.vmeOut(i).data
    debug_module.get.io.vmeOut(i).ack := dmem.io.dme.wr(i + 1).ack
  }

  val dme_ack = if(isDebugger()) Some(RegInit(VecInit(Seq.fill(numDbgs)(false.B)))) else None
  for (i <- 0 until numDbgs) {
    when(dmem.io.dme.wr(i + 1).ack) {
      dme_ack.get(i) := true.B
    }
  }

  def isDMEAck(): Bool = {
    if (numDbgs == 0)
      true.B
    else {
      dme_ack.get.reduceLeft(_ && _)
    }
  }

  val cache_done = RegInit(false.B)
  when(state === sFlush) {
    when(cache.io.cpu.flush_done) {
      cache_done := true.B
    }
  }

  switch(state) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): 0x${Hexadecimal(t._1)}, "))
        printf(p"\nVals: ")
        if (numVals > 0) {
          vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): 0x${Hexadecimal(t._1)}, "))
        } else {
          printf("N/A")
        }
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache_done && isDMEAck()) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  dcr.io.dcr.finish := last

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

  //Specific for FPGA
//  io.host.b.bits.id := io.host.w.bits.id
//  io.host.r.bits.id := io.host.ar.bits.id
//
//  io.host.b.bits.user <> DontCare
//  io.host.r.bits.user <> DontCare
//  io.host.r.bits.last := 1.U

}


package memGen.memory.cache

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.memory.message._
import chisel3.util.Arbiter
import dsptools.counters.CounterWithReset
import memGen.util._
import memGen.interfaces._
import memGen.interfaces.Action
import memGen.interfaces.axi._


class programmableCacheIO (implicit val p:Parameters) extends Bundle
with HasCacheAccelParams
with HasAccelShellParams
with MessageParams{
    val in = new Bundle{
        val cpu     = Flipped(Decoupled((new InstBundle())))
        val memCtrl = Flipped(Decoupled((new InstBundle())))
    }
    val out = new Bundle{
        val req = Valid (new Bundle{
            val dst = UInt(dstLen.W)
            val req = new IntraNodeBundle()
        })
        val resp = Decoupled(new IntraNodeBundle())
    }
    
}

class programmableCache (implicit val p:Parameters) extends Module
with HasCacheAccelParams
with HasAccelShellParams{

    val io = IO(new programmableCacheIO())

    val cache    = Module(new Gem5Cache())
    val tbe      = Module(new TBETable())
    val lockMem  = Module(new lockVector())
    val stateMem = Module (new stateMem())
    val pc       = Module(new PC())
    val arbiter  = Module (new Arbiter(new InstBundle(), n = 2))



    stateMem.io  <> DontCare
    cache.io.cpu <> DontCare

    /********************************************************************************/
    // Building ROMs
    val (routineAddr,setStateDst) = RoutinePtr.generateRoutineAddrMap(RoutineROM.routineActions)
    val (rombits, dstStateBits)   = RoutinePtr.generateTriggerRoutineBit(routineAddr, nextRoutine.routineTriggerList)

    val uCodedNextPtr = VecInit(rombits)
    val dstStateRom = VecInit(dstStateBits)

    val actions = RoutinePtr.generateActionRom(RoutineROM.routineActions, ActionList.actions, setStateDst)
    val actionRom = for (i <- 0 until nParal) yield {
        val actionRom = VecInit(actions)
        actionRom
    }

    //  printf(p"actionRom ${actionRom(0)}")

    /********************************************************************************/



    val instruction = Wire(Decoupled(new InstBundle()))

    val missLD = Wire(Bool())
    val missLDReg = Reg(Bool())

    val state    = Wire(UInt(stateLen.W))
    val inputTBE = Wire(Vec(nParal, new TBE))

    val addr = RegInit(0.U(addrLen.W))
    val event = RegInit(0.U(eventLen.W))
    val data = RegInit(0.U(bBits.W))

    val pcWire = Wire(Vec(nParal, new PCBundle()))
    val updatedPC = Wire(Vec(nParal, UInt(pcLen.W)))
    val updatedPCValid = Wire(Vec(nParal, Bool()))
    val dataValid = Wire(Bool())


    val tbeAction   = Wire(Vec(nParal, UInt(nSigs.W)))
    val cacheAction = Wire(Vec(nParal, UInt(nSigs.W)))
    val stateAction = Wire(Vec(nParal, Bool()))
//    val memAction = Wire(Vec(nParal, Bool()))

    val isTBEAction   = Wire(Vec(nParal, Bool()))
    val isStateAction = Wire(Vec(nParal, Bool()))
    val isCacheAction = Wire(Vec(nParal, Bool()))
    val isMemAction =   Wire(Vec(nParal, Bool()))

    val isLocked      = Wire(Bool())
    val hitLD         = Wire(Bool())

    val updateTBEWay   = Wire(Vec(nParal, Bool()))
    val updateTBEState = Wire(Vec(nParal, Bool()))

    val stall = WireInit(false.B)
    val stallInput = WireInit(false.B)
    val bubble = WireInit(stallInput)

    val readTBE   = Wire(Bool())
    val checkLock = Wire(Bool())
    val getState  = Wire(Bool())

    val routineAddrResValid = Wire(Bool())
    val actionResValid      = Wire(Vec(nParal, Bool()))

    val defaultState = Wire(new State())

    val firstLineNextRoutine = Wire(Vec(nParal, Bool()))
    val endOfRoutine         = Wire(Vec(nParal, Bool()))

    val routine = WireInit( Cat (event, state))
    val cacheWayReg  = RegInit(VecInit(Seq.fill(nParal + 1)(nWays.U((wayLen+1).W))))
    val cacheWayWire = Wire(Vec(nParal + 1, (UInt((wayLen+1).W))))
    val updateWay = Wire(Vec(nParal, Bool()))

    val wayInputCache = Wire(UInt((wayLen+1).W))
    val replaceWayInputCache = Wire(UInt((wayLen+1).W))
    val tbeWay        = RegInit(nWays.U((wayLen+1).W))

    val routineQueue = Module( new Queue( UInt((eventLen + stateLen).W), pipe = true, entries = 1 ))

    val actionReg  = for (i <- 0 until nParal) yield {
        val ActionReg =  Module(new Queue( new ActionBundle(), pipe = true, entries = 1))
        ActionReg
    }

    val dstOfSetState = Wire(Vec(nParal, new State()))
    val stateMemOutput = Wire((new State()))

    val probeStart = WireInit(instruction.fire())

    val tbeActionInRom = Wire(Vec(nParal, Bool()))

    val addrWire   = WireInit(instruction.bits.addr)

    val addrInputCache  = Wire(UInt(addrLen.W))
    val dataInputCache = Wire(UInt(bBits.W))

    //latching
    when(instruction.fire() ){
        addr := instruction.bits.addr
        event := instruction.bits.event
        data := instruction.bits.data
    }

    for (i <- 0 until (nParal + 1) ) {
        when(cache.io.cpu(i).resp.fire()) {
            cacheWayReg(i) := cache.io.cpu(i).resp.bits.way
        }
        cacheWayWire(i) := cache.io.cpu(i).resp.bits.way
    }

    when(tbe.io.outputTBE.fire()){
        tbeWay := tbe.io.outputTBE.bits.way
    }.otherwise{
        tbeWay := nWays.U
    }

    /*************************************************************************/
    // control signals

    val cpuPriority = 1

    /**************
    tempe
    **************/
      val (_, timeout) = CounterWithReset(true.B, 100, probeStart)


    arbiter.io.in(cpuPriority) <> io.in.cpu
    arbiter.io.in(0) <> io.in.memCtrl // priority is for lower producer
    instruction <> arbiter.io.out

    missLD := (cacheWayWire(nParal) === nWays.U) & probeStart & !isLocked & (arbiter.io.chosen === cpuPriority.U) & (instruction.bits.event === Events.EventArray("LOAD").U)

    when(missLD | !missLD & arbiter.io.chosen =/= cpuPriority.U){
        missLDReg := missLD
    }

    io.in.memCtrl.ready := !stallInput
    io.in.cpu.ready := !stallInput
    io.out.req.valid := false.B

    stallInput := isLocked | pc.io.isFull

    instruction.ready := !stallInput  // @todo should be changed for stalled situations

    readTBE     := RegEnable(instruction.fire(), false.B, instruction.ready)
    checkLock   := RegEnable(instruction.fire(), false.B, instruction.ready)
    getState    := RegEnable(instruction.fire(), false.B, instruction.ready)

    routineAddrResValid := RegEnable(readTBE , false.B, !stall)

    for (i <- 0 until nParal) {
        isTBEAction(i) :=   (actionReg(i).io.deq.bits.action.actionType === 1.U)
        isCacheAction(i) := (actionReg(i).io.deq.bits.action.actionType === 0.U)
        isStateAction(i) := (actionReg(i).io.deq.bits.action.actionType === 2.U | actionReg(i).io.deq.bits.action.actionType === 3.U)
        isMemAction(i) := isCacheAction(i) & (actionReg(i).io.deq.bits.action.signals === sigToAction(ActionList.actions("DataRQ")))
    }

    /*************************************************************************/


    /*************************************************************************/
    // Elements
    defaultState := State.default
    state := Mux(tbe.io.outputTBE.valid, tbe.io.outputTBE.bits.state.state, Mux(stateMem.io.out.valid, stateMem.io.out.bits.state, defaultState.state ))

    routineQueue.io.enq.bits := uCodedNextPtr(routine)
    routineQueue.io.enq.valid := !pc.io.isFull & readTBE & !isLocked

    val replacer  =  ReplacementPolicy.fromString(replacementPolicy, nWays)
    when(probeStart) {replacer.miss}

    for (i <- 0 until nParal) {

        updateTBEState(i) := isStateAction(i)
        updateTBEWay(i)   := isStateAction(i)
        endOfRoutine(i)   := isStateAction(i)

        actionResValid(i):= RegEnable((routineAddrResValid | (!routineAddrResValid & !firstLineNextRoutine(i))), false.B , !stall)
        tbeActionInRom(i) := (actionResValid(i) & isTBEAction(i))

        actionReg(i).io.enq.bits.action.signals := sigToAction(actionRom(i)(pcWire(i).pc))
        actionReg(i).io.enq.bits.action.actionType := sigToActType(actionRom(i)(pcWire(i).pc))
        actionReg(i).io.enq.bits.addr := pcWire(i).addr
        actionReg(i).io.enq.bits.way  := Mux(updateWay(i), cacheWayWire(i), pcWire(i).way)
        actionReg(i).io.enq.bits.data := pcWire(i).data
        actionReg(i).io.enq.bits.replaceWay := pcWire(i).replaceWay

    }

    for (i <- 0 until nParal) {
        firstLineNextRoutine(i) := (sigToAction(actionRom(i)(pcWire(i).pc)).asUInt() === 0.U ) // @todo all of them should be changed for stall
        updatedPC(i) := Mux(firstLineNextRoutine(i), pcWire(i).pc, pcWire(i).pc + 1.U  )
        updatedPCValid(i) := !firstLineNextRoutine(i)
    }

    pc.io.write.bits.addr := addrInputCache
    pc.io.write.bits.way := wayInputCache
    pc.io.write.bits.replaceWay := replaceWayInputCache
    pc.io.write.bits.pc := routineQueue.io.deq.bits
    pc.io.write.bits.data := dataInputCache
    pc.io.write.bits.valid := true.B
    pc.io.write.valid := routineQueue.io.deq.fire() & routineAddrResValid
    routineQueue.io.deq.ready := !pc.io.isFull


    for (i <- 0 until nParal) {
        updateWay(i) := pc.io.read(i).out.bits.way === nWays.U & cache.io.cpu(i).resp.fire()
        pc.io.read(i).in.bits.data.addr := DontCare //
        pc.io.read(i).in.bits.data.way := Mux(updateWay(i), cacheWayWire(i), pc.io.read(i).out.bits.way  )
        pc.io.read(i).in.bits.data.data := DontCare //
        pc.io.read(i).in.bits.data.pc := updatedPC(i)
        pc.io.read(i).in.bits.data.replaceWay := DontCare
        pc.io.read(i).in.bits.data.valid := updatedPCValid(i) // @todo should be changed for stall

        pc.io.read(i).in.valid := DontCare // @todo Should be changed probably

//        pcWire(i).pc   := pc.io.read(i).out.bits.pc
//        pcWire(i).way  := pc.io.read(i).out.bits.way
//        pcWire(i).addr  := addr
        pcWire(i) <> pc.io.read(i).out.bits

    }

    wayInputCache := (RegEnable(Mux( tbeWay === nWays.U , cacheWayReg(nParal), tbeWay ), nWays.U, !stallInput))
    replaceWayInputCache := RegEnable(replacer.get_replace_way(0.U), 0.U, !stallInput)
    addrInputCache := (RegEnable(addr, 0.U, !stallInput))
    dataInputCache := (RegEnable(data, 0.U, !stallInput))

    for (i <- 0 until nParal){
        tbeAction(i) := Mux(isTBEAction(i), actionReg(i).io.deq.bits.action.signals, tbe.idle)
        cacheAction(i) := Mux(isCacheAction(i), actionReg(i).io.deq.bits.action.signals, 0.U(nSigs.W))
        stateAction(i) := isStateAction(i)

        dstOfSetState(i).state := Mux( isStateAction(i), sigToState (actionReg(i).io.deq.bits.action.signals), State.default.state)

        actionReg(i).io.deq.ready := !stall
        actionReg(i).io.enq.valid := pcWire(i).valid  // @todo enq ready should be used for controlling  updated pc

    }
    /*************************************************************************************/


    // TBE
    tbe.io.read.valid := readTBE
    tbe.io.read.bits.addr := addr

    for (i <- 0 until nParal)  {

        inputTBE(i).state.state := dstOfSetState(i).state
        inputTBE(i).way         := actionReg(i).io.deq.bits.way // @todo WRONG

        tbe.io.write(i).bits.command := Mux(updateTBEWay(i) | updateTBEState(i), tbe.write, tbeAction(i)) // @todo Wrong
        tbe.io.write(i).bits.addr := actionReg(i).io.deq.bits.addr
        tbe.io.write(i).bits.inputTBE := inputTBE(i)
        tbe.io.write(i).bits.mask := tbe.maskAll // @todo Should be double-checked
        tbe.io.write(i).valid := DontCare
    }

    // lock Mem
    lockMem.io.lock.in.bits.data := DontCare
    lockMem.io.lock.in.bits.addr  := addr
    lockMem.io.lock.in.valid := checkLock
    lockMem.io.lock.in.bits.cmd := true.B // checking and locking
    isLocked := Mux(lockMem.io.lock.out.valid, lockMem.io.lock.out.bits, false.B)

    for (i <- 0 until nParal)  {
        lockMem.io.unLock(i).in.bits.data := DontCare
        lockMem.io.unLock(i).in.bits.addr := actionReg(i).io.deq.bits.addr
        lockMem.io.unLock(i).in.bits.cmd := false.B //unlock
        lockMem.io.unLock(i).in.valid := endOfRoutine(i)
    }

    // @todo tbe should have a higher priority for saving dst state
    // State Memory
    for (i <- 0 until nParal)  {
        stateMem.io.in(i).bits.isSet := true.B
        stateMem.io.in(i).bits.addr := actionReg(i).io.deq.bits.addr //
        stateMem.io.in(i).bits.state := dstOfSetState(i)
        stateMem.io.in(i).bits.way := actionReg(i).io.deq.bits.way
        stateMem.io.in(i).valid := isStateAction(i)
    }

    stateMem.io.in(nParal).bits.isSet := false.B // used for getting
    stateMem.io.in(nParal).bits.addr := addr
    stateMem.io.in(nParal).bits.state := DontCare
    stateMem.io.in(nParal).bits.way :=  cacheWayWire(nParal)
    stateMem.io.in(nParal).valid := getState
    stateMemOutput := stateMem.io.out.bits

    // Cache Logic
    for (i <- 0 until nParal) {
        cache.io.cpu(i).req.bits.way := actionReg(i).io.deq.bits.way
        cache.io.cpu(i).req.bits.command := cacheAction(i)
        cache.io.cpu(i).req.bits.addr := actionReg(i).io.deq.bits.addr
//        cache.io.cpu(i).req.valid := actionResValid(i) // todo  WRONG for stall
        cache.io.cpu(i).req.valid := actionReg(i).io.deq.fire()
        cache.io.cpu(i).req.bits.data := actionReg(i).io.deq.bits.data
        cache.io.cpu(i).req.bits.replaceWay := actionReg(i).io.deq.bits.replaceWay


    }
    cache.io.cpu(nParal).req.bits.way := DontCare
    cache.io.cpu(nParal).req.bits.command := Mux(probeStart, sigToAction(ActionList.actions("Probe")), 0.U)
    cache.io.cpu(nParal).req.bits.addr := Mux(probeStart, addrWire, 0.U)
    cache.io.cpu(nParal).req.valid := probeStart
    cache.io.cpu(nParal).req.bits.replaceWay := DontCare // should be changed

    hitLD :=  (cacheWayWire(nParal) =/= nWays.U) & probeStart & !isLocked
    cache.io.bipassLD.in.valid := hitLD
    cache.io.bipassLD.in.bits.addr  := addr
    cache.io.bipassLD.in.bits.way := cacheWayWire(nParal)
    // data := cache.io.bipassLD.out.bits
    dataValid := cache.io.bipassLD.out.valid


    for (i <- 0 until nParal) {
        io.out.req.bits.req.inst := 0.U // for reading
        io.out.req.bits.req.data := DontCare
        io.out.req.bits.req.addr := actionReg(i).io.deq.bits.addr
        io.out.req.bits.dst := 0.U // 0 for memCtrl
        io.out.req.valid := isMemAction(i)
    }


    for (i <- 0 until nParal) {
        io.out.resp.bits.inst := 0.U // for reading
        io.out.resp.bits.data := cache.io.cpu(i).resp.bits.data
        io.out.resp.bits.addr := actionReg(i).io.deq.bits.addr
        io.out.resp.valid := cache.io.cpu(i).resp.valid & cache.io.cpu(i).resp.bits.iswrite
    }

    


}
package memGen.memory.cache

import chipsalliance.rocketchip.config._
import chisel3._
import chisel3.util._
import memGen.config._
import memGen.interfaces._
import memGen.interfaces.axi._
import memGen.memory.message._

//class CacheInputBundle[T <: Bundle ](val gen: T) (implicit val p:Parameters) extends Bundle with HasCacheAccelParams{
//  val cpu = gen.cloneType
//  val memCtrl = Flipped(Decoupled(gen.cloneType))
//}

class CacheNodeIO (implicit val p:Parameters) extends Bundle with HasCacheAccelParams{

  val in = new Bundle{
    val cpu = Flipped(Decoupled((new IntraNodeBundle())))
    val memCtrl = Flipped(Decoupled((new IntraNodeBundle())))
  }
  val out = new Bundle{
    val network = Valid(new MessageBundle())
    val cpu = Decoupled(new IntraNodeBundle())
  }
}

class CacheNode (val UniqueID : Int = 0)(implicit val p:Parameters) extends Module with HasCacheAccelParams{

  val io = IO(new CacheNodeIO())
  val ID = WireInit(UniqueID.U)

//  val packetizer = Module(new Packetizer(IntraNodeBundle.default))
//  val depacketizer = Module(new Depacketizer(IntraNodeBundle.default))

  val cache = Module(new programmableCache())

  val cpuQueue = Module(new Queue(new IntraNodeBundle(), entries = 1, pipe = true))
  val memCtrlQueue= Module(new Queue(new IntraNodeBundle(), entries = 1, pipe = true))

  cpuQueue.io.enq <> io.in.cpu
  memCtrlQueue.io.enq <> io.in.memCtrl

  cache.io.in.cpu.bits.event := cpuQueue.io.deq.bits.inst
  cache.io.in.cpu.bits.addr  := cpuQueue.io.deq.bits.addr
  cache.io.in.cpu.bits.data  := cpuQueue.io.deq.bits.data
  cache.io.in.cpu.valid := cpuQueue.io.deq.valid
  cpuQueue.io.deq.ready := cache.io.in.cpu.ready

  cache.io.in.memCtrl.bits.event := memCtrlQueue.io.deq.bits.inst
  cache.io.in.memCtrl.bits.addr  := memCtrlQueue.io.deq.bits.addr
  cache.io.in.memCtrl.bits.data  := memCtrlQueue.io.deq.bits.data
  cache.io.in.memCtrl.valid := memCtrlQueue.io.deq.valid
  memCtrlQueue.io.deq.ready := cache.io.in.memCtrl.ready

  io.out.network.valid := cache.io.out.req.valid
  io.out.network.bits.src := ID
  io.out.network.bits.dst := cache.io.out.req.bits.dst
  io.out.network.bits.inst:= cache.io.out.req.bits.req.inst
  io.out.network.bits.data := cache.io.out.req.bits.req.data
  io.out.network.bits.addr := cache.io.out.req.bits.req.addr

  io.out.cpu.bits.data := cache.io.out.resp.bits.data
  io.out.cpu.bits.addr := cache.io.out.resp.bits.addr
  io.out.cpu.bits.inst := cache.io.out.resp.bits.inst
  io.out.cpu.valid := cache.io.out.resp.valid
  cache.io.out.resp.ready := true.B




}
package memGen.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.util._
import memGen.interfaces.axi._


/** Register File.
 *
 * Six 32-bit register file.
 *
 * -------------------------------
 * Register description    | addr
 * -------------------------|-----
 * Control status register | 0x00
 * Cycle counter           | 0x04
 * Constant value          | 0x08
 * Vector length           | 0x0c
 * Input pointer lsb       | 0x10
 * Input pointer msb       | 0x14
 * Output pointer lsb      | 0x18
 * Output pointer msb      | 0x1c
 * -------------------------------
 *
 * ------------------------------
 * Control status register | bit
 * ------------------------------
 * Launch                  | 0
 * Finish                  | 1
 * ------------------------------
 */


/** VCRBase. Parametrize base class. */
abstract class DCRBase(implicit p: Parameters) extends DandelionParameterizedBundle()(p)

/** VCRMaster.
 *
 * This is the master interface used by VCR in the DandelionShell to control
 * the Core unit.
 */
class DCRMaster(implicit val p: Parameters) extends DCRBase with HasAccelShellParams {
  val vp = dcrParams
  val mp = memParams
  val launch = Output(Bool())
  val finish = Input(Bool())
  val ecnt = Vec(vp.nECnt, Flipped(ValidIO(UInt(vp.regBits.W))))
  val vals = Output(Vec(vp.nVals, UInt(vp.regBits.W)))
  val ptrs = Output(Vec(vp.nPtrs, UInt(mp.addrBits.W)))
}

/** VCRClient.
 *
 * This is the client interface used by the Core module to communicate
 * to the VCR in the DandelionShell.
 */
class DCRClient(implicit val p: Parameters) extends DCRBase with HasAccelShellParams {
  val vp = dcrParams
  val mp = memParams
  val launch = Input(Bool())
  val finish = Output(Bool())
  val ecnt = Vec(vp.nECnt, ValidIO(UInt(vp.regBits.W)))
  val vals = Input(Vec(vp.nVals, UInt(vp.regBits.W)))
  val ptrs = Input(Vec(vp.nPtrs, UInt(mp.addrBits.W)))
}

/** DTA Control Registers (DCR).
 *
 * This unit provides control registers (32 and 64 bits) to be used by a control'
 * unit, typically a host processor. These registers are read-only by the core
 * at the moment but this will likely change once we add support to general purpose
 * registers that could be used as event counters by the Core unit.
 */
class DCR(implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val dcr = new DCRMaster
  })

  val vp = dcrParams
  val mp = memParams
  val hp = hostParams

  // Write control (AW, W, B)
  val waddr = RegInit("h_ffff".U(hp.addrBits.W)) // init with invalid address
  val wdata = io.host.w.bits.data
  val sWriteAddress :: sWriteData :: sWriteResponse :: Nil = Enum(3)
  val wstate = RegInit(sWriteAddress)

  // read control (AR, R)
  val sReadAddress :: sReadData :: Nil = Enum(2)
  val rstate = RegInit(sReadAddress)
  val rdata = RegInit(0.U(vp.regBits.W))

  // registers
  val nPtrs = if (mp.addrBits == 32) vp.nPtrs else 2 * vp.nPtrs
  val nTotal = vp.nCtrl + vp.nECnt + vp.nVals + nPtrs

  val reg = Seq.fill(nTotal)(RegInit(0.U(vp.regBits.W)))
  val addr = Seq.tabulate(nTotal)(_ * 4)
  val reg_map = (addr zip reg) map { case (a, r) => a.U -> r }
  val eo = vp.nCtrl
  val vo = eo + vp.nECnt
  val po = vo + vp.nVals

  switch(wstate) {
    is(sWriteAddress) {
      when(io.host.aw.valid) {
        wstate := sWriteData
      }
    }
    is(sWriteData) {
      when(io.host.w.valid) {
        wstate := sWriteResponse
      }
    }
    is(sWriteResponse) {
      when(io.host.b.ready) {
        wstate := sWriteAddress
      }
    }
  }

  when(io.host.aw.fire()) {
    waddr := io.host.aw.bits.addr
  }

  io.host.aw.ready := wstate === sWriteAddress
  io.host.w.ready := wstate === sWriteData
  io.host.b.valid := wstate === sWriteResponse
  io.host.b.bits.resp := 0.U

  switch(rstate) {
    is(sReadAddress) {
      when(io.host.ar.valid) {
        rstate := sReadData
      }
    }
    is(sReadData) {
      when(io.host.r.ready) {
        rstate := sReadAddress
      }
    }
  }

  io.host.ar.ready := rstate === sReadAddress
  io.host.r.valid := rstate === sReadData
  io.host.r.bits.data := rdata
  io.host.r.bits.resp := 0.U

  when(io.dcr.finish) {
    reg(0) := "b_10".U
  }.elsewhen(io.host.w.fire() && addr(0).U === waddr) {
    reg(0) := wdata
  }

  for (i <- 0 until vp.nECnt) {
    when(io.dcr.ecnt(i).valid) {
      reg(eo + i) := io.dcr.ecnt(i).bits
    }.elsewhen(io.host.w.fire() && addr(eo + i).U === waddr) {
      reg(eo + i) := wdata
    }
  }

  for (i <- 0 until (vp.nVals + nPtrs)) {
    when(io.host.w.fire() && addr(vo + i).U === waddr) {
      reg(vo + i) := wdata
    }
  }

  when(io.host.ar.fire()) {
    rdata := MuxLookup(io.host.ar.bits.addr, 0.U, reg_map)
  }

  io.dcr.launch := reg(0)(0)

  for (i <- 0 until vp.nVals) {
    io.dcr.vals(i) := reg(vo + i)
  }

  if (mp.addrBits == 32) { // 32-bit pointers
    for (i <- 0 until nPtrs) {
      io.dcr.ptrs(i) := reg(po + i)
    }
  } else { // 64-bits pointers
    for (i <- 0 until (nPtrs / 2)) {
      io.dcr.ptrs(i) := Cat(reg(po + 2 * i + 1), reg(po + 2 * i))
    }
  }
}

package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}

package memGen.interfaces


import chisel3._
import chisel3.util.{Decoupled, log2Ceil}
import chipsalliance.rocketchip.config._
import utility.Constants._
import memGen.config._
import chipsalliance.rocketchip.config._
import memGen.memory.cache.HasCacheAccelParams

import scala.collection.immutable.ListMap

/*==============================================================================
=            Notes
           1. AVOID DECLARING IOs, DECLARE BUNDLES. Create IOs within your node.
           2.             =
==============================================================================*/

abstract class CoreBundle (implicit val p:Parameters) extends ParameterizedBundle()(p) with HasCacheAccelParams

trait Event extends CoreBundle{
  val event = UInt(eventLen.W)
}
trait Addr extends CoreBundle{
  val addr = UInt(addrLen.W)
}

class InstBundle (implicit p: Parameters) extends Event with Addr{

  val data = UInt(bBits.W)
  override def cloneType: this.type = new InstBundle().asInstanceOf[this.type]
}

class Action(implicit p:Parameters) extends CoreBundle{
  val signals = UInt(nSigs.W)
  val actionType = UInt(2.W)
  override def cloneType: this.type = new Action().asInstanceOf[this.type]

}




trait ValidT extends AccelBundle {
  val valid = Bool()
}


trait RouteID extends AccelBundle {
  val RouteID = UInt(glen.W)
}

trait TaskID extends AccelBundle {
  val taskID = UInt(tlen.W)
}

trait PredicateT extends AccelBundle {
  val predicate = Bool()
}

// Maximum of 16MB Stack Array.

class AllocaIO(implicit p: Parameters) extends AccelBundle()(p) {
  val size = UInt(xlen.W)
  val numByte = UInt(xlen.W)
  val predicate = Bool()
  val valid = Bool()
}

object AllocaIO {
  def default(implicit p: Parameters): AllocaIO = {
    val temp_w = Wire(new AllocaIO)
    temp_w.size := 0.U
    temp_w.numByte := 0.U
    temp_w.predicate := true.B
    temp_w.valid := false.B
    temp_w
  }
}

// alloca indicates id of stack object and returns address back.
// Can be any of the 4MB regions. Size is over provisioned
class AllocaReq(implicit p: Parameters) extends AccelBundle()(p) with RouteID {
  val size = UInt(xlen.W)
  val numByte = UInt(xlen.W)
}

object AllocaReq {
  def default(implicit p: Parameters): AllocaReq = {
    val wire = Wire(new AllocaReq)
    wire.size := 0.U
    wire.numByte := 0.U
    wire.RouteID := 0.U
    wire
  }
}

// ptr is the address returned back to the alloca call.
// Valid and Data flipped.
class AllocaResp(implicit p: Parameters)
  extends ValidT with RouteID {
  val ptr = UInt(xlen.W)
}

object AllocaResp {
  def default(implicit p: Parameters): AllocaResp = {
    val wire = Wire(new AllocaResp)
    wire.RouteID := 0.U
    wire.ptr := 0.U
    wire.valid := false.B
    wire
  }
}

// Read interface into Scratchpad stack
//  address: Word aligned address to read from
//  node : dataflow node id to return data to
class ReadReq(implicit p: Parameters)
  extends RouteID {
  val address = UInt(xlen.W)
  val taskID = UInt(tlen.W)
  val Typ = UInt(8.W)

}

object ReadReq {
  def default(implicit p: Parameters): ReadReq = {
    val wire = Wire(new ReadReq)
    wire.address := 0.U
    wire.taskID := 0.U
    wire.RouteID := 0.U
    wire.Typ := MT_D
    wire
  }
}


//  data : data returned from scratchpad
class ReadResp(implicit p: Parameters)
  extends ValidT
    with RouteID {
  val data = UInt(xlen.W)

  override def toPrintable: Printable = {
    p"ReadResp {\n" +
      p"  valid  : ${valid}\n" +
      p"  RouteID: ${RouteID}\n" +
      p"  data   : 0x${Hexadecimal(data)} }"
  }
}

object ReadResp {
  def default(implicit p: Parameters): ReadResp = {
    val wire = Wire(new ReadResp)
    wire.data := 0.U
    wire.RouteID := 0.U
    wire.valid := false.B
    wire
  }
}

/**
  * Write request to memory
  *
  * @param p [description]
  * @return [description]
  */
//
// Word aligned to write to
// Node performing the write
// Mask indicates which bytes to update.
class WriteReq(implicit p: Parameters)
  extends RouteID {
  val address = UInt((xlen - 10).W)
  val data = UInt(xlen.W)
  val mask = UInt((xlen / 8).W)
  val taskID = UInt(tlen.W)
  val Typ = UInt(8.W)
}

object WriteReq {
  def default(implicit p: Parameters): WriteReq = {
    val wire = Wire(new WriteReq)
    wire.address := 0.U
    wire.data := 0.U
    wire.mask := 0.U
    wire.taskID := 0.U
    wire.RouteID := 0.U
    wire.Typ := MT_D
    wire
  }
}

// Explicitly indicate done flag
class WriteResp(implicit p: Parameters)
  extends ValidT
    with RouteID {
  val done = Bool()
}

//  data : data returned from scratchpad
class FUResp(implicit p: Parameters)
  extends ValidT
    with RouteID {
  val data = UInt(xlen.W)

  override def toPrintable: Printable = {
    p"FUResp {\n" +
      p"  valid  : ${valid}\n" +
      p"  RouteID: ${RouteID}\n" +
      p"  data   : 0x${Hexadecimal(data)} }"
  }
}

object FUResp {
  def default(implicit p: Parameters): FUResp = {
    val wire = Wire(new FUResp)
    wire.data := 0.U
    wire.RouteID := 0.U
    wire.valid := false.B
    wire
  }
}

class MemReq(implicit p: Parameters) extends AccelBundle()(p) {
  val addr = UInt(addrLen.W)
  val data = UInt(bSize.W)
  val mask = UInt((xlen / 8).W)
  val tag = UInt((List(1, mshrLen).max).W)
  val taskID = UInt(tlen.W)
  val iswrite = Bool()
  val tile = UInt(xlen.W)
  val command = UInt(nSigs.W)
  val way = UInt((log2Ceil(accelParams.nways) + 1).W)
  val replaceWay = way.cloneType
//  val state = UInt(4.W)




  def clone_and_set_tile_id(tile: UInt): MemReq = {
    val wire = Wire(new MemReq())
    wire.addr := this.addr
    wire.data := this.data
    wire.mask := this.mask
    wire.tag := this.tag
    wire.taskID := this.taskID
    wire.iswrite := this.iswrite
    wire.command := this.command
    wire.way := this.way
    wire.replaceWay := this.replaceWay
    wire.tile := tile
//    wire.state := this.state
    wire
  }
}

object MemReq {
  def default(implicit p: Parameters): MemReq = {
    val wire = Wire(new MemReq())
    wire.addr := 0.U
    wire.data := 0.U
    wire.mask := 0.U
    wire.tag := 0.U
    wire.taskID := 0.U
    wire.iswrite := false.B
    wire.tile := 0.U
    wire.command := 0.U
    wire.way := 0.U
    wire.replaceWay := 0.U
    wire
  }
}

class MemResp(implicit p: Parameters) extends AccelBundle()(p) with ValidT {
  val data = UInt(bSize.W)
  val tag = UInt((List(1, mshrLen).max).W)
  val iswrite = Bool()
  val tile = UInt(xlen.W)
  val way = UInt((log2Ceil(accelParams.nways) + 1).W)

  //  val state = UInt(4.W)

  def clone_and_set_tile_id(tile: UInt): MemResp = {
    val wire = Wire(new MemResp())
    wire.data := this.data
    wire.tag := this.tag
    wire.iswrite := this.iswrite
    wire.way := this.way
    wire.tile := tile

    wire
  }
}

object MemResp {
  def default(implicit p: Parameters): MemResp = {
    val wire = Wire(new MemResp())
    wire.valid := false.B
    wire.data := 0.U
    wire.tag := 0.U
    wire.iswrite := false.B
    wire.tile := 0.U
    wire.way := 0.U

//    wire.state := 0.U
    wire
  }
}



//class RelayNode output
class RelayOutput(implicit p: Parameters) extends AccelBundle()(p) {
  override def cloneType = new RelayOutput().asInstanceOf[this.type]

  val DataNode = Decoupled(UInt(xlen.W))
  val TokenNode = Input(UInt(tlen.W))
}

/**
  * Data bundle between dataflow nodes.
  *
  * @note 2 fields
  *       data : U(xlen.W)
  *       predicate : Bool
  * @param p : implicit
  * @return
  */
//class DataBundle(implicit p: Parameters) extends ValidT with PredicateT
class DataBundle(implicit p: Parameters) extends PredicateT with TaskID {
  // Data packet
  val data = UInt(xlen.W)

  def asControlBundle(): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := this.predicate
    wire.taskID := this.taskID
    wire
  }
}


object DataBundle {

  def apply(data: UInt = 0.U, taskID: UInt = 0.U)(implicit p: Parameters): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := data
    wire.predicate := true.B
    wire.taskID := taskID
    wire
  }

  def apply(data: UInt, taskID: UInt, predicate: UInt)(implicit p: Parameters): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := data
    wire.predicate := predicate
    wire.taskID := taskID
    wire
  }


  def default(implicit p: Parameters): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := 0.U
    wire.predicate := false.B
    wire.taskID := 0.U
    wire
  }

  def active(data: UInt = 0.U)(implicit p: Parameters): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := data
    wire.predicate := true.B
    wire.taskID := 0.U
    wire
  }

  def deactivate(data: UInt = 0.U)(implicit p: Parameters): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := data
    wire.predicate := false.B
    wire.taskID := 0.U
    wire
  }
}

class TypBundle(implicit p: Parameters) extends ValidT with PredicateT with TaskID {
  // Type Packet
  val data = UInt(typeSize.W)
}


object TypBundle {
  def default(implicit p: Parameters): TypBundle = {
    val wire = Wire(new TypBundle)
    wire.data := 0.U
    wire.predicate := false.B
    wire.taskID := 0.U
    wire.valid := false.B
    wire
  }
}

/**
  * Control bundle between branch and
  * basicblock nodes
  *
  * control  : Bool
  */
class ControlBundle(implicit p: Parameters) extends AccelBundle()(p) {
  //Control packet
  val taskID = UInt(tlen.W)
  val control = Bool()

  def asDataBundle(): DataBundle = {
    val wire = Wire(new DataBundle)
    wire.data := this.control.asUInt()
    wire.predicate := this.control
    wire.taskID := this.taskID
    wire
  }
}

object ControlBundle {
  def default(implicit p: Parameters): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := false.B
    wire.taskID := 0.U
    wire
  }

  def default(control: Bool, task: UInt)(implicit p: Parameters): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := control
    wire.taskID := task
    wire
  }

  def active(taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := true.B
    wire.taskID := taskID
    wire
  }

  def deactivate(taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := false.B
    wire.taskID := taskID
    wire
  }


  def apply(control: Bool = false.B, taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
    val wire = Wire(new ControlBundle)
    wire.control := control
    wire.taskID := taskID
    wire
  }

}


/**
  * Custom Data bundle between dataflow nodes.
  *
  * @note 2 fields
  *       data : U(len.W)
  *       predicate : Bool
  * @return
  */
class CustomDataBundle[T <: Data](gen: T = UInt(32.W))(implicit p: Parameters) extends AccelBundle()(p) {
  // Data packet
  val data = gen.cloneType
  val predicate = Bool()
  val taskID = UInt(tlen.W)

  override def cloneType: this.type = new CustomDataBundle(gen).asInstanceOf[this.type]
}

object CustomDataBundle {
  def apply[T <: Data](gen: T)(implicit p: Parameters): CustomDataBundle[T] = new CustomDataBundle(gen)

  def default[T <: Data](gen: T)(implicit p: Parameters): CustomDataBundle[T] = {
    val wire = Wire(new CustomDataBundle(gen))
    wire.data := 0.U.asTypeOf(gen)
    wire.predicate := false.B
    wire.taskID := 0.U
    wire
  }
}

/**
  * Bundle with variable (parameterizable) types and/or widths
  * VariableData   - bundle of DataBundles of different widths
  * VariableCustom - bundle of completely different types
  * These classes create a record with a configurable set of fields like:
  * "data0"
  * "data1", etc.
  * The bundle fields can either be of type CustomDataBundle[T] (any type) or of
  * DataBundle depending on class used.
  *
  * Examples:
  * var foo = VariableData(List(32, 16, 8))
  * foo("field0") is DataBundle with UInt(32.W)
  * foo("field1") is DataBundle with UInt(16.W)
  * foo("field2") is DataBundle with UInt(8.W)
  * var foo = VariableCustom(List(Int(32.W), UInt(16.W), Bool())
  * foo("field0") is CustomDataBundle with Int(32.W)
  * foo("field1") is CustomDataBundle with UInt(16.W)
  * foo("field2") is CustomDataBundle with Bool()
  *
  */

// Bundle of types specified by the argTypes parameter
class VariableCustom(val argTypes: Seq[Bits])(implicit p: Parameters) extends Record {
  var elts = Seq.tabulate(argTypes.length) {
    i => s"field$i" -> CustomDataBundle(argTypes(i))
  }
  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)

  def apply(elt: String) = elements(elt)

  override def cloneType = new VariableCustom(argTypes).asInstanceOf[this.type]
}

// Bundle of decoupled types specified by the argTypes parameter
class VariableDecoupledCustom(val argTypes: Seq[Bits])(implicit p: Parameters) extends Record {
  var elts = Seq.tabulate(argTypes.length) {
    i => s"field$i" -> (Decoupled(CustomDataBundle(argTypes(i))))
  }
  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)

  def apply(elt: String) = elements(elt)

  override def cloneType = new VariableDecoupledCustom(argTypes).asInstanceOf[this.type]
}

// Bundle of DataBundles with data width specified by the argTypes parameter
class VariableData(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {

  var elts = Seq.tabulate(argTypes.length) {
    i =>
      s"field$i" -> new DataBundle()(
        p.alterPartial({ case DandelionConfigKey => p(DandelionConfigKey).copy(dataLen = argTypes(i)) })
      )
  }
  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)

  def apply(elt: String) = elements(elt)

  override def cloneType = new VariableData(argTypes).asInstanceOf[this.type]
}

// Bundle of Decoupled DataBundles with data width specified by the argTypes parameter
class VariableDecoupledData(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {
  var elts = Seq.tabulate(argTypes.length) {
    i =>
      s"field$i" -> Decoupled(new DataBundle()(
        p.alterPartial({ case DandelionConfigKey => p(DandelionConfigKey).copy(dataLen = argTypes(i)) })
      )
      )
  }
  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)

  def apply(elt: String) = elements(elt)

  override def cloneType = new VariableDecoupledData(argTypes).asInstanceOf[this.type]
}

// Bundle of Decoupled DataBundle Vectors. Data width is default. Intended for use on outputs
// of a block (i.e. configurable number of output with configurable number of copies of each output)
class VariableDecoupledVec(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {
  var elts = Seq.tabulate(argTypes.length) {
    i => s"field$i" -> Vec(argTypes(i), Decoupled(new DataBundle()(p)))
  }
  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)

  def apply(elt: String) = elements(elt)

  override def cloneType = new VariableDecoupledVec(argTypes).asInstanceOf[this.type]
}

// Call type that wraps an enable and variable DataBundle together
class Call(val argTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable = new ControlBundle
  val data = new VariableData(argTypes)

  override def cloneType = new Call(argTypes).asInstanceOf[this.type]
}

// Call type that wraps an enable and variable DataBundle together
class CallDCR(val ptrsArgTypes: Seq[Int],
              val valsArgTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable   = new ControlBundle
  val dataPtrs = new VariableData(ptrsArgTypes)
  val dataVals = new VariableData(valsArgTypes)

  override def cloneType = new CallDCR(ptrsArgTypes, valsArgTypes).asInstanceOf[this.type]
}

// Call type that wraps a decoupled enable and decoupled variable data bundle together
class CallDecoupled(val argTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable = Decoupled(new ControlBundle)
  val data = new VariableDecoupledData(argTypes)

  override def cloneType = new CallDecoupled(argTypes).asInstanceOf[this.type]
}

// Call type that wraps a decoupled enable and decoupled vector DataBundle together
class CallDecoupledVec(val argTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable = Decoupled(new ControlBundle)
  val data = new VariableDecoupledVec(argTypes)

  override def cloneType = new CallDecoupledVec(argTypes).asInstanceOf[this.type]
}


// Call type that wraps a decoupled enable and decoupled variable data bundle together
class CallDCRDecoupled(val ptrsArgTypes: Seq[Int],
                       val valsArgTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable = Decoupled(new ControlBundle)
  val dataPtrs = new VariableDecoupledData(ptrsArgTypes)
  val dataVals = new VariableDecoupledData(valsArgTypes)

  override def cloneType = new CallDCRDecoupled(ptrsArgTypes, valsArgTypes).asInstanceOf[this.type]
}

// Call type that wraps a decoupled enable and decoupled vector DataBundle together
class CallDCRDecoupledVec(val ptrsArgTypes: Seq[Int],
                          val valsArgTypes: Seq[Int])(implicit p: Parameters) extends AccelBundle() {
  val enable = Decoupled(new ControlBundle)
  val dataPtrs = new VariableDecoupledVec(ptrsArgTypes)
  val dataVals = new VariableDecoupledVec(valsArgTypes)

  override def cloneType = new CallDCRDecoupledVec(ptrsArgTypes, valsArgTypes).asInstanceOf[this.type]
}

// Function unit request type
class FUReq(val argTypes: Seq[Int])(implicit p: Parameters) extends RouteID {
  val data = new VariableData(argTypes)

  override def cloneType = new FUReq(argTypes).asInstanceOf[this.type]
}

package memGen.memory.cache
//
//
import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.util._
import memGen.interfaces._
import memGen.interfaces.axi._
//
//import scala.collection.immutable.ListMap
//
///*==============================================================================
//=            Notes
//           1. AVOID DECLARING IOs, DECLARE BUNDLES. Create IOs within your node.
//           2.             =
//==============================================================================*/
//


class CacheBankedMemIO[T <: Data](D: T, nInput :Int) (implicit val p: Parameters) extends Bundle
  with HasCacheAccelParams
  with HasAccelShellParams {

    val bank = Output(UInt(wayLen.W))
    val address = Output(UInt(setLen.W))
    val isRead = Output(Bool())
    val outputValue = Output(D.cloneType)
    val inputValue = Input(Vec(nInput, D.cloneType))
    val valid = Output(Bool())
}

class RegIO [T <: Data](D:T, nRead: Int)(implicit val p: Parameters) extends Bundle
  with HasCacheAccelParams
  with HasAccelShellParams {

    val write = Valid(new Bundle {
        val addr = (UInt(xlen.W))
        val value = (D.cloneType)
    })

    val read = new Bundle{
        val in = (Valid(new Bundle {
            val addr = (UInt(xlen.W))
        }))
        val out = Vec(nRead, Input(D.cloneType))
    }

}


class portNoAddr[T1 <: Data, T2 <: Data](D: T1, O: T2 )(implicit val p :Parameters) extends Bundle
  with HasCacheAccelParams {

    val in = Flipped(Valid(new Bundle {
        val data = D.cloneType
    }))

    val out = Valid(O.cloneType)

    override def cloneType: this.type =  new portNoAddr(D,O).asInstanceOf[this.type]
}

class port[T1 <: Data, T2 <: Data](D: T1, O: T2 )(addrLen: Int)(implicit val p :Parameters) extends Bundle
  with HasCacheAccelParams {

    val in = Flipped(Valid(new Bundle {
        val addr = UInt(addrLen.W)
        val data = D.cloneType
    }))

    val out = Valid(O.cloneType)

    override def cloneType: this.type =  new port(D,O)(addrLen).asInstanceOf[this.type]
}

class portWithCMD[T1 <: Data, T2 <: Data, T3 <: Data](D: T1, C: T2, O: T3 )(addrLen: Int)(override implicit val p :Parameters)
  extends port(D,O)(addrLen)(p)
    with HasCacheAccelParams {

    override val in = Flipped(Valid(new Bundle {
        val addr = UInt(addrLen.W)
        val data = D.cloneType
        val cmd  = C.cloneType
    }))

    override def cloneType: this.type =  new portWithCMD(D,C,O)(addrLen).asInstanceOf[this.type]
}

class CacheBundle (implicit p:Parameters) extends AXIAccelBundle
  with HasCacheAccelParams {

    val addr = UInt(addrLen.W)
    val way  = UInt(wayLen.W)
    val data = UInt(bBits.W)
    val replaceWay =  UInt(wayLen.W)

}

class PCBundle (implicit p:Parameters) extends CacheBundle
  with HasCacheAccelParams {

    val pc = UInt(pcLen.W)
    val valid = Bool()
}

class ActionBundle (implicit p:Parameters) extends CacheBundle
  with HasCacheAccelParams {
    val action = new Action()
}

object PCBundle {

    def default (implicit p:Parameters): PCBundle =  {
        val pcContent = Wire(new PCBundle())
        pcContent.addr := 0.U
        pcContent.pc := 0.U
        pcContent.valid := false.B
        pcContent.way := pcContent.nWays.U
        pcContent.data := 0.U
        pcContent.replaceWay := 0.U
        pcContent

    }
}
//trait ValidT extends CoreBundle {
//  val valid = Bool()
//}
//
//
//trait RouteID extends CoreBundle {
//  val RouteID = UInt(glen.W)
//}
//
//trait TaskID extends CoreBundle {
//  val taskID = UInt(tlen.W)
//}
//
//trait PredicateT extends CoreBundle {
//  val predicate = Bool()
//}
//
//trait Row extends CoreBundle {
//  val row = UInt(rowLen.W)
//}
//
//trait Col extends CoreBundle {
//  val col = UInt(colLen.W)
//}
//// Maximum of 16MB Stack Array.
//
//class AllocaIO(implicit p: Parameters) extends CoreBundle()(p) {
//  val size = UInt(xlen.W)
//  val numByte = UInt(xlen.W)
//  val predicate = Bool()
//  val valid = Bool()
//}
//
//object AllocaIO {
//  def default(implicit p: Parameters): AllocaIO = {
//    val temp_w = Wire(new AllocaIO)
//    temp_w.size := 0.U
//    temp_w.numByte := 0.U
//    temp_w.predicate := true.B
//    temp_w.valid := false.B
//    temp_w
//  }
//}
//
//// alloca indicates id of stack object and returns address back.
//// Can be any of the 4MB regions. Size is over provisioned
//class AllocaReq(implicit p: Parameters) extends CoreBundle()(p) with RouteID {
//  val size = UInt(xlen.W)
//  val numByte = UInt(xlen.W)
//}
//
//object AllocaReq {
//  def default(implicit p: Parameters): AllocaReq = {
//    val wire = Wire(new AllocaReq)
//    wire.size := 0.U
//    wire.numByte := 0.U
//    wire.RouteID := 0.U
//    wire
//  }
//}
//
//// ptr is the address returned back to the alloca call.
//// Valid and Data flipped.
//class AllocaResp(implicit p: Parameters)
//  extends ValidT with RouteID {
//  val ptr = UInt(xlen.W)
//}
//
//object AllocaResp {
//  def default(implicit p: Parameters): AllocaResp = {
//    val wire = Wire(new AllocaResp)
//    wire.RouteID := 0.U
//    wire.ptr := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
//// Read interface into Scratchpad stack
////  address: Word aligned address to read from
////  node : dataflow node id to return data to
//class ReadReq(implicit p: Parameters)
//  extends RouteID {
//  val address = UInt(xlen.W)
//  val taskID = UInt(tlen.W)
//  val Typ = UInt(8.W)
//
//}
//
//object ReadReq {
//  def default(implicit p: Parameters): ReadReq = {
//    val wire = Wire(new ReadReq)
//    wire.address := 0.U
//    wire.taskID := 0.U
//    wire.RouteID := 0.U
//    wire.Typ := MT_W
//    wire
//  }
//}
//
//
////  data : data returned from scratchpad
//class ReadResp(implicit p: Parameters)
//  extends ValidT
//    with RouteID {
//  val data = UInt(xlen.W)
//
//  override def toPrintable: Printable = {
//    p"ReadResp {\n" +
//      p"  valid  : ${valid}\n" +
//      p"  RouteID: ${RouteID}\n" +
//      p"  data   : 0x${Hexadecimal(data)} }"
//  }
//}
//
//object ReadResp {
//  def default(implicit p: Parameters): ReadResp = {
//    val wire = Wire(new ReadResp)
//    wire.data := 0.U
//    wire.RouteID := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
///** Tensor Read interface into tensorFile of TensorLoads
// *  index: index of tensorFile
// *  node : dataflow node id to return data to
// **/
//class TensorReadReq(implicit p: Parameters)
//  extends RouteID {
//  val index = UInt(xlen.W)
//  val taskID = UInt(tlen.W)
//}
//
//object TensorReadReq {
//  def default(implicit p: Parameters): TensorReadReq = {
//    val wire = Wire(new TensorReadReq())
//    wire.index := 0.U
//    wire.taskID := 0.U
//    wire.RouteID := 0.U
//    wire
//  }
//}
//
////  data : data returned from tensorFile
//class TensorReadResp(val dataWidth: Int)(implicit p: Parameters) extends ValidT  with RouteID {
//  val data = UInt(dataWidth.W)
//  override def cloneType = new TensorReadResp(dataWidth).asInstanceOf[this.type]
//
//  override def toPrintable: Printable = {
//    p"TensorReadResp {\n" +
//      p"  valid  : ${valid}\n" +
//      p"  RouteID: ${RouteID}\n" +
//      p"  data   : 0x${Hexadecimal(data)} }"
//  }
//}
//
//object TensorReadResp {
//  def default(dataWidth: Int)(implicit p: Parameters): TensorReadResp = {
//    val wire = Wire(new TensorReadResp(dataWidth))
//    wire.data := 0.U
//    wire.RouteID := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
//
///**
//  * Write request to memory
//  *
//  * @param p [description]
//  * @return [description]
//  */
////
//// Word aligned to write to
//// Node performing the write
//// Mask indicates which bytes to update.
//class WriteReq(implicit p: Parameters)
//  extends RouteID {
//  val address = UInt((xlen - 10).W)
//  val data = UInt(xlen.W)
//  val mask = UInt((xlen / 8).W)
//  val taskID = UInt(tlen.W)
//  val Typ = UInt(8.W)
//}
//
//object WriteReq {
//  def default(implicit p: Parameters): WriteReq = {
//    val wire = Wire(new WriteReq)
//    wire.address := 0.U
//    wire.data := 0.U
//    wire.mask := 0.U
//    wire.taskID := 0.U
//    wire.RouteID := 0.U
//    wire.Typ := MT_W
//    wire
//  }
//}
//
//// Explicitly indicate done flag
//class WriteResp(implicit p: Parameters)
//  extends ValidT
//    with RouteID {
//  val done = Bool()
//}
//
///**
//  * Tensor Write request to tensorFile
//  * @param p [description]
//  * @return [description]
//  */
//
//class TensorWriteReq(val dataWidth: Int)(implicit p: Parameters)
//  extends RouteID {
//  override def cloneType = new TensorWriteReq(dataWidth).asInstanceOf[this.type]
//  val index = UInt(xlen.W)
//  val data = UInt(dataWidth.W)
//  val mask = UInt((xlen / 8).W)
//  val taskID = UInt(tlen.W)
//}
//
//object TensorWriteReq {
//  def default(dataWidth: Int)(implicit p: Parameters): TensorWriteReq = {
//    val wire = Wire(new TensorWriteReq(dataWidth))
//    wire.index := 0.U
//    wire.data := 0.U
//    wire.mask := 0.U
//    wire.taskID := 0.U
//    wire.RouteID := 0.U
//    wire
//  }
//}
//
//// Explicitly indicate done flag
//class TensorWriteResp(implicit p: Parameters)
//  extends ValidT
//    with RouteID {
//  val done = Bool()
//}
//
//// ----------------------------------------------
////  data : data returned from scratchpad
//class FUResp(implicit p: Parameters)
//  extends ValidT
//    with RouteID {
//  val data = UInt(xlen.W)
//
//  override def toPrintable: Printable = {
//    p"FUResp {\n" +
//      p"  valid  : ${valid}\n" +
//      p"  RouteID: ${RouteID}\n" +
//      p"  data   : 0x${Hexadecimal(data)} }"
//  }
//}
//
//object FUResp {
//  def default(implicit p: Parameters): FUResp = {
//    val wire = Wire(new FUResp)
//    wire.data := 0.U
//    wire.RouteID := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
//class MemReq(implicit p: Parameters) extends CoreBundle()(p) {
//  val addr = UInt(xlen.W)
//  val data = UInt(xlen.W)
//  val mask = UInt((xlen / 8).W)
//  val tag = UInt((List(1, mshrlen).max).W)
//  val taskID = UInt(tlen.W)
//  val iswrite = Bool()
//  val tile = UInt(xlen.W)
//
//  def clone_and_set_tile_id(tile: UInt): MemReq = {
//    val wire = Wire(new MemReq())
//    wire.addr := this.addr
//    wire.data := this.data
//    wire.mask := this.mask
//    wire.tag := this.tag
//    wire.taskID := this.taskID
//    wire.iswrite := this.iswrite
//    wire.tile := tile
//    wire
//  }
//}
//
//object MemReq {
//  def default(implicit p: Parameters): MemReq = {
//    val wire = Wire(new MemReq())
//    wire.addr := 0.U
//    wire.data := 0.U
//    wire.mask := 0.U
//    wire.tag := 0.U
//    wire.taskID := 0.U
//    wire.iswrite := false.B
//    wire.tile := 0.U
//    wire
//  }
//}
//
//class MemResp(implicit p: Parameters) extends CoreBundle()(p) with ValidT {
//  val data = UInt(xlen.W)
//  val tag = UInt((List(1, mshrlen).max).W)
//  val iswrite = Bool()
//  val tile = UInt(xlen.W)
//
//  def clone_and_set_tile_id(tile: UInt): MemResp = {
//    val wire = Wire(new MemResp())
//    wire.data := this.data
//    wire.tag := this.tag
//    wire.iswrite := this.iswrite
//    wire.tile := tile
//    wire
//  }
//}
//
//object MemResp {
//  def default(implicit p: Parameters): MemResp = {
//    val wire = Wire(new MemResp())
//    wire.valid := false.B
//    wire.data := 0.U
//    wire.tag := 0.U
//    wire.iswrite := false.B
//    wire.tile := 0.U
//    wire
//  }
//}
//
////class RelayNode output
//class RelayOutput(implicit p: Parameters) extends CoreBundle()(p) {
//  override def cloneType = new RelayOutput().asInstanceOf[this.type]
//
//  val DataNode = Decoupled(UInt(xlen.W))
//  val TokenNode = Input(UInt(tlen.W))
//}
//
///**
//  * Data bundle between dataflow nodes.
//  *
//  * @note 2 fields
//  *       data : U(xlen.W)
//  *       predicate : Bool
//  * @param p : implicit
//  * @return
//  */
////class DataBundle(implicit p: Parameters) extends ValidT with PredicateT
//class DataBundle(implicit p: Parameters) extends PredicateT with TaskID {
//  // Data packet
//  val data = UInt(xlen.W)
//
//  def asControlBundle(): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := this.predicate
//    wire.taskID := this.taskID
//    wire
//  }
//}
//
//
//object DataBundle {
//  def default(implicit p: Parameters): DataBundle = {
//    val wire = Wire(new DataBundle)
//    wire.data := 0.U
//    wire.predicate := false.B
//    wire.taskID := 0.U
//    wire
//  }
//
//  def active(data: UInt = 0.U)(implicit p: Parameters): DataBundle = {
//    val wire = Wire(new DataBundle)
//    wire.data := data
//    wire.predicate := true.B
//    wire.taskID := 0.U
//    wire
//  }
//
//  def deactivate(data: UInt = 0.U)(implicit p: Parameters): DataBundle = {
//    val wire = Wire(new DataBundle)
//    wire.data := data
//    wire.predicate := false.B
//    wire.taskID := 0.U
//    wire
//  }
//
//  def apply(data : UInt = 0.U , taskID: UInt = 0.U)(implicit p: Parameters): DataBundle = {
//    val wire = Wire(new DataBundle())
//    wire.data := data
//    wire.taskID := taskID
//    wire.predicate := true.B
//    wire
//  }
//
//
//}
//
//class TypBundle(implicit p: Parameters) extends ValidT with PredicateT with TaskID {
//  // Type Packet
//  val data = UInt(Typ_SZ.W)
//}
//
//
//object TypBundle {
//  def default(implicit p: Parameters): TypBundle = {
//    val wire = Wire(new TypBundle)
//    wire.data := 0.U
//    wire.predicate := false.B
//    wire.taskID := 0.U
//    wire.valid := false.B
//    wire
//  }
//
//  def active(data: UInt = 0.U)(implicit p: Parameters): TypBundle = {
//    val wire = Wire(new TypBundle)
//    wire.data := data
//    wire.predicate := true.B
//    wire.taskID := 0.U
//    wire.valid := true.B
//    wire
//  }
//}
//
///**
//  * Control bundle between branch and
//  * basicblock nodes
//  *
//  * control  : Bool
//  */
//class ControlBundle(implicit p: Parameters) extends CoreBundle()(p) {
//  //Control packet
//  val taskID = UInt(tlen.W)
//  val control = Bool()
//
//  def asDataBundle(): DataBundle = {
//    val wire = Wire(new DataBundle)
//    wire.data := this.control.asUInt()
//    wire.predicate := this.control
//    wire.taskID := this.taskID
//    wire
//  }
//}
//
//object ControlBundle {
//  def default(implicit p: Parameters): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := false.B
//    wire.taskID := 0.U
//    wire
//  }
//
//  def default(control: Bool, task: UInt)(implicit p: Parameters): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := control
//    wire.taskID := task
//    wire
//  }
//
//  def active(taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := true.B
//    wire.taskID := taskID
//    wire
//  }
//
//  def deactivate(taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := false.B
//    wire.taskID := taskID
//    wire
//  }
//
//
//  def apply(control: Bool = false.B, taskID: UInt = 0.U)(implicit p: Parameters): ControlBundle = {
//    val wire = Wire(new ControlBundle)
//    wire.control := control
//    wire.taskID := taskID
//    wire
//  }
//
//}
//
//
///**
//  * Custom Data bundle between dataflow nodes.
//  *
//  * @note 2 fields
//  *       data : U(len.W)
//  *       predicate : Bool
//  * @return
//  */
//class CustomDataBundle[T <: Data](gen: T = UInt(32.W))(implicit p: Parameters) extends ValidT with PredicateT with TaskID {
//  // Data packet
//  val data = gen.cloneType
//
//  override def cloneType: this.type = new CustomDataBundle(gen).asInstanceOf[this.type]
//}
//
//object CustomDataBundle {
//  def apply[T <: Data](gen: T)(implicit p: Parameters): CustomDataBundle[T] = new CustomDataBundle(gen)
//
//  def default[T <: Data](gen: T)(implicit p: Parameters): CustomDataBundle[T] = {
//    val wire = Wire(new CustomDataBundle(gen))
//    wire.data := 0.U.asTypeOf(gen)
//    wire.predicate := false.B
//    wire.taskID := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
///**
//  * Coordinate Data bundle between dataflow nodes.
//  *
//  * @note 2 fields
//  *       row : U(len.W)
//  *       column : U(len.W)
//  *       data : U(len.W)
//  * @return
//  */
//class CooDataBundle[T <: Data](gen: T = UInt(32.W))(implicit p: Parameters) extends ValidT with Row with Col {
//  // Data packet
//  val data = gen.cloneType
//
//  override def cloneType: this.type = new CooDataBundle(gen).asInstanceOf[this.type]
//}
//
//object CooDataBundle {
//  def apply[T <: Data](gen: T)(implicit p: Parameters): CooDataBundle[T] = new CooDataBundle(gen)
//
//  def default[T <: Data](gen: T)(implicit p: Parameters): CooDataBundle[T] = {
//    val wire = Wire(new CooDataBundle(gen))
//    wire.data := 0.U.asTypeOf(gen)
//    wire.row := 0.U
//    wire.col := 0.U
//    wire.valid := false.B
//    wire
//  }
//}
//
///**
//  * Custom Data bundle between dataflow nodes.
//  *
//  * @note 2 fields
//  *       data : U(len.W)
//  *       predicate : Bool
//  * @return
//  */
//class BoolBundle[T <: Data](gen: T = Bool())(implicit p: Parameters) extends ValidT {
//  // Data packet
//  val data = gen.cloneType
//
//  override def cloneType: this.type = new BoolBundle(gen).asInstanceOf[this.type]
//}
//
//object BoolBundle {
//  def apply[T <: Data](gen: T)(implicit p: Parameters): BoolBundle[T] = new BoolBundle(gen)
//
//  def default[T <: Data](gen: T)(implicit p: Parameters): BoolBundle[T] = {
//    val wire = Wire(new BoolBundle(gen))
//    wire.data := false.B.asTypeOf(gen)
//    wire.valid := false.B
//    wire
//  }
//}
///**
//  * Bundle with variable (parameterizable) types and/or widths
//  * VariableData   - bundle of DataBundles of different widths
//  * VariableCustom - bundle of completely different types
//  * These classes create a record with a configurable set of fields like:
//  * "data0"
//  * "data1", etc.
//  * The bundle fields can either be of type CustomDataBundle[T] (any type) or of
//  * DataBundle depending on class used.
//  *
//  * Examples:
//  * var foo = VariableData(List(32, 16, 8))
//  * foo("field0") is DataBundle with UInt(32.W)
//  * foo("field1") is DataBundle with UInt(16.W)
//  * foo("field2") is DataBundle with UInt(8.W)
//  * var foo = VariableCustom(List(Int(32.W), UInt(16.W), Bool())
//  * foo("field0") is CustomDataBundle with Int(32.W)
//  * foo("field1") is CustomDataBundle with UInt(16.W)
//  * foo("field2") is CustomDataBundle with Bool()
//  *
//  */
//
//// Bundle of types specified by the argTypes parameter
//class VariableCustom(val argTypes: Seq[Bits])(implicit p: Parameters) extends Record {
//  var elts = Seq.tabulate(argTypes.length) {
//    i => s"field$i" -> CustomDataBundle(argTypes(i))
//  }
//  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)
//
//  def apply(elt: String) = elements(elt)
//
//  override def cloneType = new VariableCustom(argTypes).asInstanceOf[this.type]
//}
//
//// Bundle of decoupled types specified by the argTypes parameter
//class VariableDecoupledCustom(val argTypes: Seq[Bits])(implicit p: Parameters) extends Record {
//  var elts = Seq.tabulate(argTypes.length) {
//    i => s"field$i" -> (Decoupled(CustomDataBundle(argTypes(i))))
//  }
//  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)
//
//  def apply(elt: String) = elements(elt)
//
//  override def cloneType = new VariableDecoupledCustom(argTypes).asInstanceOf[this.type]
//}
//
//// Bundle of DataBundles with data width specified by the argTypes parameter
//class VariableData(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {
//  var elts = Seq.tabulate(argTypes.length) {
//    i => s"field$i" -> new DataBundle()(p.alterPartial({ case XLEN => argTypes(i) }))
//  }
//  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)
//
//  def apply(elt: String) = elements(elt)
//
//  override def cloneType = new VariableData(argTypes).asInstanceOf[this.type]
//}
//
//// Bundle of Decoupled DataBundles with data width specified by the argTypes parameter
//class VariableDecoupledData(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {
//  var elts = Seq.tabulate(argTypes.length) {
//    i => s"field$i" -> Decoupled(new DataBundle()(p.alterPartial({ case XLEN => argTypes(i) })))
//  }
//  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)
//
//  def apply(elt: String) = elements(elt)
//
//  override def cloneType = new VariableDecoupledData(argTypes).asInstanceOf[this.type]
//}
//
//// Bundle of Decoupled DataBundle Vectors. Data width is default. Intended for use on outputs
//// of a block (i.e. configurable number of output with configurable number of copies of each output)
//class VariableDecoupledVec(val argTypes: Seq[Int])(implicit p: Parameters) extends Record {
//  var elts = Seq.tabulate(argTypes.length) {
//    i => s"field$i" -> Vec(argTypes(i), Decoupled(new DataBundle()(p)))
//  }
//  override val elements = ListMap(elts map { case (field, elt) => field -> elt.cloneType }: _*)
//
//  def apply(elt: String) = elements(elt)
//
//  override def cloneType = new VariableDecoupledVec(argTypes).asInstanceOf[this.type]
//}
//
//// Call type that wraps an enable and variable DataBundle together
//class Call(val argTypes: Seq[Int])(implicit p: Parameters) extends CoreBundle() {
//  val enable = new ControlBundle
//  val data = new VariableData(argTypes)
//
//  override def cloneType = new Call(argTypes).asInstanceOf[this.type]
//}
//
//// Call type that wraps a decoupled enable and decoupled variable data bundle together
//class CallDecoupled(val argTypes: Seq[Int])(implicit p: Parameters) extends CoreBundle() {
//  val enable = Decoupled(new ControlBundle)
//  val data = new VariableDecoupledData(argTypes)
//
//  override def cloneType = new CallDecoupled(argTypes).asInstanceOf[this.type]
//}
//
//// Call type that wraps a decoupled enable and decoupled vector DataBundle together
//class CallDecoupledVec(val argTypes: Seq[Int])(implicit p: Parameters) extends CoreBundle() {
//  val enable = Decoupled(new ControlBundle)
//  val data = new VariableDecoupledVec(argTypes)
//
//  override def cloneType = new CallDecoupledVec(argTypes).asInstanceOf[this.type]
//}
//
//// Function unit request type
//class FUReq(val argTypes: Seq[Int])(implicit p: Parameters) extends RouteID {
//  val data = new VariableData(argTypes)
//
//  override def cloneType = new FUReq(argTypes).asInstanceOf[this.type]
//}

package memGen.memory.message

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.util._
import memGen.memory.cache._
import memGen.interfaces._
import memGen.interfaces.axi._
import chisel3.util.experimental.loadMemoryFromFile

trait MessageParams extends HasAccelParams with HasCacheAccelParams{
    val srcLen  = 3
    val dstLen  = 3
    val instLen = 8
    override val dataLen = nData * xlen

}

class IntraNodeBundle (implicit val p : Parameters) extends Bundle with
MessageParams{
    val addr = UInt(addrLen.W)
    val inst = UInt(instLen.W)
    val data = UInt (dataLen.W)
}

object IntraNodeBundle {
    def default(implicit p:Parameters) : IntraNodeBundle = {
        val node = Wire(new IntraNodeBundle()(p))
        node.addr := 0.U
        node.inst := 0.U
        node.data := 0.U
        node
    }

    def default(node: IntraNodeBundle)(implicit p:Parameters) : IntraNodeBundle = {
        node.addr := 0.U
        node.inst := 0.U
        node.data := 0.U
        node
    }}

class MessageBundle (implicit p :Parameters) extends IntraNodeBundle()(p){
    val src = UInt(srcLen.W)
    val dst = UInt(dstLen.W)
}
object MessageBundle {
    def default(implicit p: Parameters): MessageBundle = {
        val message = Wire(new MessageBundle()(p))
        IntraNodeBundle.default(message)
        message.src := 0.U
        message.dst := 0.U
        message
    }
}




package memGen.config

import chisel3._
import chisel3.util.Enum
import chipsalliance.rocketchip.config._
import memGen.fpu.FType
import memGen.interfaces.axi.AXIParams
import memGen.junctions.{NastiKey, NastiParameters}
import memGen.util.{DandelionGenericParameterizedBundle, DandelionParameterizedBundle}


trait AccelParams {

  var xlen: Int
  var ylen: Int
  val tlen: Int
  val glen: Int
  val typeSize: Int
  val beats: Int
  val mshrLen: Int
  val fType: FType

  //Cache
  val nways: Int
  val nsets: Int

  def cacheBlockBytes: Int

  // Debugging dumps
  val log: Boolean
  val clog: Boolean
  val verb: String
  val comp: String
}

/**
  * VCR parameters.
  * These parameters are used on VCR interfaces and modules.
  */
trait DCRParams {
  val nCtrl: Int
  val nECnt: Int
  val nVals: Int
  val nPtrs: Int
  val regBits: Int
}

/**
  * DME parameters.
  * These parameters are used on DME interfaces and modules.
  */
trait DMEParams {
  val nReadClients: Int
  val nWriteClients: Int
}


case class DandelionAccelParams(
                                 dataLen: Int = 64,
                                 addrLen: Int = 32,
                                 taskLen: Int = 5,
                                 groupLen: Int = 16,
                                 mshrLen: Int = 8,
                                 tSize: Int = 64,
                                 verbosity: String = "low",
                                 components: String = "",
                                 printLog: Boolean = false,
                                 printMemLog: Boolean = false,
                                 printCLog: Boolean = false,
                                 cacheNWays: Int = 4,
                                 cacheNSets: Int = 8,
                                 cacheNState:Int = 8,
                                 cacheAddrLen:Int = 32,
                                 nSigs:Int = 10,
                                 actionLen: Int = 10 + 2,
                                 tbeSize:Int= 4

                               ) extends AccelParams {

  var xlen: Int = dataLen
  var ylen: Int = addrLen
  val tlen: Int = taskLen
  val glen: Int = groupLen
  val typeSize: Int = tSize
  val beats: Int = 0
  val mshrlen: Int = mshrLen
  val fType = dataLen match {
    case 64 => FType.D
    case 32 => FType.S
    case 16 => FType.H
  }

  //Cache
  val nways = cacheNWays
  val nsets = cacheNSets
  val nstates = cacheNState
  val addrlen = cacheAddrLen
  val nWords = 4

//  val nCommand = nCom
//  var comlen:Int = math.ceil(math.log(nCommand)/math.log(2)).toInt
//  val nSigs = nSigs

    def cacheBlockBytes: Int = nWords * (xlen >> 3) // 4 x 32 bits = 16B
  val cacheBlockBits = cacheBlockBytes << 3
//   def cacheBlockBytes: Int = xlen >> 3
  // Debugging dumps
  val log: Boolean = printLog
  val memLog: Boolean = printMemLog
  val clog: Boolean = printCLog
  val verb: String = verbosity
  val comp: String = components

}

/**
  * VCR parameters.
  * These parameters are used on VCR interfaces and modules.
  */
case class DandelionDCRParams(numCtrl: Int = 1,
                              numEvent: Int = 1,
                              numVals: Int = 2,
                              numPtrs: Int = 4,
                              numRets: Int = 0) {
  val nCtrl = numCtrl
  val nECnt = numEvent + numRets
  val nVals = numVals
  val nPtrs = numPtrs
  val regBits = 32
}

/**
  * DME parameters.
  * These parameters are used on DME interfaces and modules.
  */
case class DandelionDMEParams(numRead: Int = 1,
                              numWrite: Int = 1) {
  val nReadClients: Int = numRead
  val nWriteClients: Int = numWrite
  require(nReadClients > 0,
    s"\n\n[Dandelion] [DMEParams] nReadClients must be larger than 0\n\n")
  require(
    nWriteClients > 0,
    s"\n\n[Dandelion] [DMEParams] nWriteClients must be larger than 0\n\n")
}

class ParameterizedBundle(implicit p: Parameters) extends Bundle {
     override def cloneType = {
         try {
             this.getClass.getConstructors.head.newInstance(p).asInstanceOf[this.type]
           } catch {
          case e: java.lang.IllegalArgumentException =>
                throw new Exception("Unable to use ParamaterizedBundle.cloneType on " +
                 this.getClass + ", probably because " + this.getClass +
                                "() takes more than one argument.  Consider overriding " +
                                "cloneType() on " + this.getClass, e)
      }
     }
  }

/** Shell parameters. */
case class ShellParams(
                        val hostParams: AXIParams,
                        val memParams: AXIParams,
                        val vcrParams: DandelionDCRParams,
                        val dmeParams: DandelionDMEParams
                      )


case object DandelionConfigKey extends Field[DandelionAccelParams]

case object DCRKey extends Field[DandelionDCRParams]

case object DMEKey extends Field[DandelionDMEParams]

case object HostParamKey extends Field[AXIParams]

case object MemParamKey extends Field[AXIParams]


class WithAccelConfig(inParams: DandelionAccelParams = DandelionAccelParams())
  extends Config((site, here, up) => {
    // Core
    case DandelionConfigKey => inParams
  }
  )


/**
  * Please note that the dLen from WithSimShellConfig should be the same value as
  * AXI -- memParams:dataBits
  *
  * @param vcrParams
  * @param dmeParams
  * @param hostParams
  * @param memParams
  */
class WithTestConfig(vcrParams: DandelionDCRParams = DandelionDCRParams(),
                      dmeParams: DandelionDMEParams = DandelionDMEParams(),
                      hostParams: AXIParams = AXIParams(
                        addrBits = 16, dataBits = 64, idBits = 13, lenBits = 4),
                      memParams: AXIParams = AXIParams(
                        addrBits = 32, dataBits = 64, userBits = 5,
                        lenBits = 8, // limit to 16 beats, instead of 256 beats in AXI4
                        coherent = true),
                      nastiParams: NastiParameters = NastiParameters(dataBits = 32, addrBits = 32, idBits = 13))
  extends Config((site, here, up) => {
    // Core
    case DCRKey => vcrParams
    case DMEKey => dmeParams
    case HostParamKey => hostParams
    case MemParamKey => memParams
    case NastiKey => nastiParams
  }
  )



trait HasAccelParams {
  implicit val p: Parameters

  def accelParams: DandelionAccelParams = p(DandelionConfigKey)

  val xlen = accelParams.xlen
  val addrLen = accelParams.addrLen
  val bSize = accelParams.cacheBlockBits
  val ylen = accelParams.ylen
  val tlen = accelParams.tlen
  val glen = accelParams.glen
  val mshrLen = accelParams.mshrLen
  val typeSize = accelParams.typeSize
  val beats = typeSize / xlen
  val fType = accelParams.fType
  val log = accelParams.log
  val memLog = accelParams.memLog
  val clog = accelParams.clog
  val verb = accelParams.verb
  val comp = accelParams.comp
  val nSigs = accelParams.nSigs
  val tbeDepth = accelParams.tbeSize



}

trait HasAccelShellParams {
  implicit val p: Parameters

  def dcrParams: DandelionDCRParams = p(DCRKey)

  def dmeParams: DandelionDMEParams = p(DMEKey)

  def hostParams: AXIParams = p(HostParamKey)

  def memParams: AXIParams = p(MemParamKey)

  def nastiParams: NastiParameters = p(NastiKey)

}

abstract class AccelBundle(implicit val p: Parameters) extends DandelionParameterizedBundle()(p)
  with HasAccelParams

abstract class AXIAccelBundle(implicit val p: Parameters) extends DandelionGenericParameterizedBundle(p)
  with HasAccelParams

package memGen.memory.cache


object nextRoutine {

    val routineTriggerList = Array [RoutinePC](

                    Routine ("LOAD_I") ,DstState("ID"), Trigger( Seq ("LOAD" , "I")),
                    Routine ("LOAD_M") ,  DstState("I"), Trigger( Seq("LOAD", "M")),
                    Routine ("STORE_I") , DstState("M"), Trigger( Seq("STORE", "I")),
                    Routine ("LOAD_ID") , DstState("ID"),Trigger( Seq ("LOAD" , "ID")),
                    Routine ("LOAD_E") ,  DstState("E"), Trigger( Seq("LOAD", "E")),
                    Routine ("STORE_IS") ,  DstState("IM"), Trigger( Seq("STORE", "IS")),
                    Routine ("DATA_ID"), DstState("D"), Trigger(Seq("DATA", "ID")),
                    






    )


  // fill the input table
}

package memGen.memory.cache

object RoutineROM {

  val routineActions = Array [RoutinePC](


    // @todo should be fixed
    Routine ("LOAD_I") , Actions(Seq( "AllocateTBE","Allocate", "DataRQ", "SetState")),DstState("ID"),
    Routine ("LOAD_M"), Actions(Seq ("DataRQ", "SetState")),  DstState("M"),
    Routine("STORE_I"), Actions(Seq("AllocateTBE","Allocate", "WrInt", "SetState")),DstState("M"),
    Routine ("LOAD_ID") , Actions(Seq( "SetState")), DstState("ID"),
    Routine ("LOAD_E") , Actions(Seq( "ReadInt","DeallocateTBE", "SetState")), DstState("E"),
    Routine ("STORE_IS") , Actions(Seq( "WrInt", "SetState")), DstState("S"),
    Routine ("DATA_ID") , Actions(Seq( "WrInt", "SetState")), DstState("E"),
    







    /*
    Allocate
    Beq allocPassed PASSED
    replace
    PASSED :
    ReadExt

     */



  )


  // fill the input table
}

package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:49:55 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:49:58 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:00 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:05 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Exception in thread "pool-3-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:10 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16
Exception in thread "pool-3-thread-2" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:12 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11
Mar. 03, 2021 11:50:12 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12
Mar. 03, 2021 11:50:12 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:14 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13
[0m2021.03.03 23:50:14 INFO  shutting down Metals[0m
[0m2021.03.03 23:50:32 INFO  Started: Metals version 0.10.0 in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim' for client vscode 1.45.1.[0m
[0m2021.03.03 23:50:36 INFO  time: initialize in 3.83s[0m
[0m2021.03.03 23:50:37 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.03 23:50:37 ERROR org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.03 23:50:38 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.03 23:50:38 ERROR unable to setup persistent H2 database with AUTO_SERVER=false, falling back to in-memory database. This means you may be redundantly asked to execute 'Import build', even if it's not needed. Also, code navigation will not work for existing files in the .metals/readonly/ directory. To fix this problem, make sure you only have one running Metals server in the directory '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'.
org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.03 23:50:39 WARN  Build server is not auto-connectable.[0m
[0m2021.03.03 23:50:41 WARN  no build tool detected in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.03 23:50:41 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
Mar. 03, 2021 11:50:43 P.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.03.03 23:50:48 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:50:57 INFO  time: code lens generation in 14s[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:50:58 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
Mar. 03, 2021 11:50:58 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:51:01 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9
Mar. 03, 2021 11:51:01 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:51:03 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4
Mar. 03, 2021 11:51:03 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15
Mar. 03, 2021 11:51:03 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13
Mar. 03, 2021 11:51:03 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:51:12 INFO  time: code lens generation in 1.08s[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:52:25 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:52:27 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:52:30 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:52:31 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:52:38 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Exception in thread "pool-3-thread-1" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:52:42 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 33
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:52:44 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38
Exception in thread "pool-3-thread-2" Mar. 03, 2021 11:52:44 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34
java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Mar. 03, 2021 11:52:44 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:52:46 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/build.sbt[0mimport sbt.complete._
import sbt.complete.DefaultParsers._
import xerial.sbt.pack._
import sys.process._

enablePlugins(PackPlugin)

lazy val commonSettings = Seq(
  organization := "edu.sfu.cs",
  name := "dandelion-sim",
  version      := "1.0-SNAPSHOT",
  scalaVersion := "2.12.10",
  parallelExecution in Global := false,
  logBuffered in Test := false,
  testOptions in Test += Tests.Argument("-oDS"),
  traceLevel   := 15,
  scalacOptions ++= Seq("-deprecation","-unchecked","-Xsource:2.11"),
  libraryDependencies ++= Seq("org.scala-lang" % "scala-reflect" % scalaVersion.value),
  addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0" cross CrossVersion.full),
  resolvers ++= Seq(
    Resolver.sonatypeRepo("snapshots"),
    Resolver.sonatypeRepo("releases"),
    Resolver.mavenLocal
  )
)

// lazy val chisel = (project in file("chisel3")).settings(commonSettings)

def dependOnChisel(prj: Project) = {
  prj.settings(
    libraryDependencies ++= Seq("edu.berkeley.cs" %% "chisel3" % "3.3-SNAPSHOT")
  )
}

lazy val `api-config-chipsalliance` = (project in file("api-config-chipsalliance/build-rules/sbt"))
  .settings(commonSettings)
  .settings(publishArtifact := false)

lazy val dandelion = dependOnChisel(project).settings(commonSettings)
  .settings(publishArtifact := false)

lazy val `memGen` = (project in file("memGen"))
  .settings(commonSettings)
  .settings(publishArtifact := false)

lazy val `dandelionsim` = dependOnChisel(project in file("."))
  .settings(commonSettings, chipSettings)
  .dependsOn(`api-config-chipsalliance` % "compile-internal;test-internal")
  .dependsOn(dandelion % "compile-internal;test-internal")
  .dependsOn(`memGen` % "compile-internal;test-internal")
  .settings(
    aggregate := false,
    // Include macro classes, resources, and sources in main jar.
    mappings in (Compile, packageBin) ++= (mappings in (`api-config-chipsalliance`, Compile, packageBin)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`api-config-chipsalliance`, Compile, packageSrc)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`memGen`, Compile, packageSrc)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (`memGen`, Compile, packageSrc)).value,
    mappings in (Compile, packageBin) ++= (mappings in (dandelion, Compile, packageBin)).value,
    mappings in (Compile, packageSrc) ++= (mappings in (dandelion, Compile, packageSrc)).value,
    exportJars := true
  )

lazy val addons = settingKey[Seq[String]]("list of addons used for this build")
lazy val make = inputKey[Unit]("trigger backend-specific makefile command")
val setMake = NotSpace ~ ( Space ~> NotSpace )

lazy val chipSettings = Seq(
  addons := {
    val a = sys.env.getOrElse("DANDELION_ADDONS", "")
    println(s"Using addons: $a")
    a.split(" ")
  },
  unmanagedSourceDirectories in Compile ++= addons.value.map(baseDirectory.value / _ / "src/main/scala"),
  mainClass in (Compile, run) := Some("dandelionsim.Generator"),
  make := {
    val jobs = java.lang.Runtime.getRuntime.availableProcessors
    val (makeDir, target) = setMake.parsed
    (run in Compile).evaluated
    s"make -C $makeDir  -j $jobs $target".!
  }
)



Mar. 03, 2021 11:52:46 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 40
Exception in thread "pool-3-thread-3" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Mar. 03, 2021 11:53:03 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 54
Exception in thread "pool-3-thread-4" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)[0m
2021.03.03 23:53:06 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/build.sbt[0m
Mar. 03, 2021 11:53:06 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 58
[0m2021.03.03 23:53:07 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/build.sbt[0m
[0m2021.03.03 23:53:20 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/build.sbt[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 03, 2021 11:53:22 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 65
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.03 23:53:44 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/FPU/FPALU.scala[0mpackage memGen.fpu

import hardfloat._
import chisel3.Module
import chisel3._
import chisel3.util._

case class FType(exp: Int, sig: Int) {
  def ieeeWidth = exp + sig

  def expWidth = exp

  def sigWidth = sig

  def recodedWidth = ieeeWidth + 1

  def qNaN = ((BigInt(7) << (exp + sig - 3)) + (BigInt(1) << (sig - 2))).U((exp + sig + 1).W)

  def isNaN(x: UInt) = x(sig + exp - 1, sig + exp - 3).andR

  def isSNaN(x: UInt) = isNaN(x) && !x(sig - 2)

  def classify(x: UInt) = {
    val sign = x(sig + exp)
    val code = x(exp + sig - 1, exp + sig - 3)
    val codeHi = code(2, 1)
    val isSpecial = codeHi === 3.U

    val isHighSubnormalIn = x(exp + sig - 3, sig - 1) < 2.U
    val isSubnormal = code === 1.U || codeHi === 1.U && isHighSubnormalIn
    val isNormal = codeHi === 1.U && !isHighSubnormalIn || codeHi === 2.U
    val isZero = code === 0.U
    val isInf = isSpecial && !code(0)
    val isNaN = code.andR
    val isSNaN = isNaN && !x(sig - 2)
    val isQNaN = isNaN && x(sig - 2)

    Cat(isQNaN, isSNaN, isInf && !sign, isNormal && !sign,
      isSubnormal && !sign, isZero && !sign, isZero && sign,
      isSubnormal && sign, isNormal && sign, isInf && sign)
  }

  // convert between formats, ignoring rounding, range, NaN
  def unsafeConvert(x: UInt, to: FType) = if (this == to) x else {
    val sign = x(sig + exp)
    val fractIn = x(sig - 2, 0)
    val expIn = x(sig + exp - 1, sig - 1)
    val fractOut = fractIn << to.sig >> sig
    val expOut = {
      val expCode = expIn(exp, exp - 2)
      val commonCase = (expIn + (1 << to.exp).U) - (1 << exp).U
      Mux(expCode === 0.U || expCode >= 6.U, Cat(expCode, commonCase(to.exp - 3, 0)), commonCase(to.exp, 0))
    }
    Cat(sign, expOut, fractOut)
  }

  def recode(x: UInt) = hardfloat.recFNFromFN(exp, sig, x)

  def ieee(x: UInt) = hardfloat.fNFromRecFN(exp, sig, x)
}

object FType {
  val S = new FType(8, 24)
  val D = new FType(11, 53)
  val H = new FType(5, 11)
}

/**
  * List of compute operations which we can support
  */
object FPAluOpCode {
  val Add = 1
  val Sub = 2
  val Mul = 3
  val Mac = 4

  val opMap = Map(
    "Add" -> Add,
    "fadd" -> Add,
    "add" -> Add,
    "Sub" -> Sub,
    "sub" -> Sub,
    "fsub" -> Sub,
    "Mul" -> Mul,
    "mul" -> Mul,
    "fmul" -> Mul,
    "Mac" -> Mac,
    "mac" -> Mac
  )
  val length = 9
}


object FPAluGenerator {
  /** @param key     a key to search for
    * @param mapping a sequence to search of keys and values
    * @return the value found or the default if not
    */
  def apply[S <: Int, T <: Data](key: S, mapping: Seq[(S, T)]): T = {

    //Assign default to first element
    var res = mapping(0)._2
    for ((k, v) <- mapping) {
      if (k == key)
        res = v
    }

    res
  }
}


/**
  * ALU class supports all the computation operations exist in LLVM
  * to use the class you only need to specify the length of inputs
  * and opCode of your alu.
  *
  * @param opCode opcode which indicates ALU operation
  * @param xlen   bit width of the inputs
  */
class FPUALU(val xlen: Int, val opCode: String, t: FType) extends Module {
  val io = IO(new Bundle {
    val in1 = Input(UInt(xlen.W))
    val in2 = Input(UInt(xlen.W))
    val out = Output(UInt(xlen.W))
  })

  /* We are hardcoding the signals at compile time to enable
     the backend synthesis tools to optimize. This is important 
     from a dataflow perspective to ensure we get the most optimal node
     for each element in the dataflow.
     If we decode, then a MUX would be needed within the hardware.
  */
  def FPUControl(): Unit = {
    FPAluOpCode.opMap(opCode) match {
      case FPAluOpCode.Add => { // b + c
        mulAddRecFN.io.op := 0.U
        mulAddRecFN.io.a := dummy1.io.out
        mulAddRecFN.io.b := in1RecFN
        mulAddRecFN.io.c := in2RecFN
      }
      case FPAluOpCode.Sub => { // b - c
        mulAddRecFN.io.op := 1.U
        mulAddRecFN.io.a := dummy1.io.out
        mulAddRecFN.io.b := in1RecFN
        mulAddRecFN.io.c := in2RecFN
      }
      case FPAluOpCode.Mul => { // a*b
        mulAddRecFN.io.op := 0.U
        mulAddRecFN.io.a := in1RecFN
        mulAddRecFN.io.b := in2RecFN
        mulAddRecFN.io.c := dummy0.io.out
      }
      case FPAluOpCode.Mac => { // a*b + c
        mulAddRecFN.io.op := 0.U
        mulAddRecFN.io.a := in1RecFN
        mulAddRecFN.io.b := in2RecFN
        mulAddRecFN.io.c := dummy0.io.out
      }
    }
  }

  /* 1 and 0 encoded in berkley hardfloat format. 
    This is useful for hardwiring some of the inputs e.g., 
    use implement b + c as 1 * b + c on a MAC.
  */
  val dummy1 = Module(new INToRecFN(t.ieeeWidth, t.expWidth, t.sigWidth))
  dummy1.io.signedIn := false.B
  dummy1.io.in := 1.U((t.ieeeWidth).W)
  dummy1.io.roundingMode := "b110".U(3.W)
  dummy1.io.detectTininess := 0.U(1.W)

  val dummy0 = Module(new INToRecFN(t.ieeeWidth, t.expWidth, t.sigWidth))
  dummy0.io.signedIn := false.B
  dummy0.io.in := 0.U((t.ieeeWidth).W)
  dummy0.io.roundingMode := "b110".U(3.W)
  dummy0.io.detectTininess := 0.U(1.W)

  /* Recode inputs into ieee format */
  val in1RecFN = t.recode(io.in1)
  val in2RecFN = t.recode(io.in2)

  val mulAddRecFN = Module(new MulAddRecFN(t.expWidth, t.sigWidth))
  mulAddRecFN.io.roundingMode := "b110".U(3.W)
  mulAddRecFN.io.detectTininess := 0.U(1.W)

  assert(!FPAluOpCode.opMap.get(opCode).isEmpty, "Wrong ALU OP!")

  FPUControl()
  io.out := t.ieee(mulAddRecFN.io.out)

  // printf(p"${Hexadecimal(io.out)}")
}



[0m2021.03.03 23:53:46 INFO  time: code lens generation in 1.3s[0m
[0m2021.03.03 23:53:51 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/FPU/SharedDiv.scala[0m
package memGen.fpu

import chisel3._
import chisel3.Module
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.interfaces._
import memGen.arbiters._
import util._
import muxes._
import hardfloat._
import chipsalliance.rocketchip.config._
import memGen.config._

class SharedFPUIO(NumOps: Int, argTypes: Seq[Int])
                 (implicit p: Parameters) extends AccelBundle( )(p) {
  val InData = Vec(NumOps, Flipped(Decoupled(new FUReq(argTypes))))

  val OutData = Vec(NumOps, Output(new FUResp))

  override def cloneType = new SharedFPUIO(NumOps, argTypes).asInstanceOf[this.type]
}

class SharedFPU(NumOps: Int, PipeDepth: Int)(t: FType)
               (implicit val p: Parameters,
                name: sourcecode.Name,
                file: sourcecode.File)
  extends Module with HasAccelParams {
  override lazy val io = IO(new SharedFPUIO(NumOps, argTypes = List(xlen, xlen, xlen)))

  // Printf debugging
  val node_name       = name.value
  val module_name     = file.value.split("/").tail.last.split("\\.").head.capitalize
  val (cycleCount, _) = Counter(true.B, 32 * 1024)

  print(t.expWidth)
  // Arguments for function unit
  val argTypes = List(xlen, xlen, xlen)
  // The function unit
  val ds       = Module(new DivSqrtRecFN_small(t.expWidth, t.sigWidth, 0))
  //  Metadata queue associated with function unit
  val RouteQ   = Module(new Queue(UInt(tlen.W), PipeDepth))

  /**
    * Instantiating Arbiter module and connecting inputs to the output
    *
    * @note we fix the base size to 8
    */
  val in_arbiter = Module(new ArbiterTree(BaseSize = 2, NumOps = NumOps, new FUReq(argTypes), Locks = 1))
  val out_demux  = Module(new DeMuxTree(BaseSize = 2, NumOps = NumOps, new FUResp))

  //@todo fix the base size
  out_demux.io.input <> DontCare

  for (i <- 0 until NumOps) {
    in_arbiter.io.in(i) <> io.InData(i)
    io.OutData(i) <> out_demux.io.outputs(i)
  }

  // Declare metadata queue associated with function unit.
  // PipeDepth = Function unit pipeline stages
  // The buffering depth of RouteQ is the maximum number of FU executions
  // that can be outstanding.
  RouteQ.io.enq.valid := in_arbiter.io.out.valid & ds.io.inReady
  RouteQ.io.enq.bits := in_arbiter.io.out.bits.RouteID

  // Wire up arbiter ready to function unit and queue ready
  in_arbiter.io.out.ready := ds.io.inReady && RouteQ.io.enq.ready
  // Wire up arbiter to function unit. Direct params to function unit
  ds.io.inValid := in_arbiter.io.out.valid
  ds.io.sqrtOp := in_arbiter.io.out.bits.data("field2").data.orR
  ds.io.a := t.recode(in_arbiter.io.out.bits.data("field0").data)
  ds.io.b := t.recode(in_arbiter.io.out.bits.data("field1").data)
  //  ds.io.a := in_arbiter.io.out.bits.data("field0").data
  //  ds.io.b := in_arbiter.io.out.bits.data("field1").data
  ds.io.roundingMode := "b110".U(3.W)
  ds.io.detectTininess := 0.U(1.W)

  out_demux.io.enable := ds.io.outValid_div || ds.io.outValid_sqrt
  RouteQ.io.deq.ready := ds.io.outValid_div || ds.io.outValid_sqrt
  out_demux.io.input.data := fNFromRecFN(t.expWidth, t.sigWidth, ds.io.out)
  out_demux.io.input.RouteID := RouteQ.io.deq.bits
  out_demux.io.input.valid := ds.io.outValid_div || ds.io.outValid_sqrt
  // Use RouteQ value to demux the output of fn
  val x = fNFromRecFN(t.expWidth, t.sigWidth, ds.io.out)

}

[0m2021.03.03 23:53:56 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/config/Configs.scala[0m
package memGen.config

import chisel3._
import chisel3.util.Enum
import chipsalliance.rocketchip.config._
import memGen.fpu.FType
import memGen.interfaces.axi.AXIParams
import memGen.junctions.{NastiKey, NastiParameters}
import memGen.util.{DandelionGenericParameterizedBundle, DandelionParameterizedBundle}


trait AccelParams {

  var xlen: Int
  var ylen: Int
  val tlen: Int
  val glen: Int
  val typeSize: Int
  val beats: Int
  val mshrLen: Int
  val fType: FType

  //Cache
  val nways: Int
  val nsets: Int

  def cacheBlockBytes: Int

  // Debugging dumps
  val log: Boolean
  val clog: Boolean
  val verb: String
  val comp: String
}

/**
  * VCR parameters.
  * These parameters are used on VCR interfaces and modules.
  */
trait DCRParams {
  val nCtrl: Int
  val nECnt: Int
  val nVals: Int
  val nPtrs: Int
  val regBits: Int
}

/**
  * DME parameters.
  * These parameters are used on DME interfaces and modules.
  */
trait DMEParams {
  val nReadClients: Int
  val nWriteClients: Int
}


case class DandelionAccelParams(
                                 dataLen: Int = 64,
                                 addrLen: Int = 32,
                                 taskLen: Int = 5,
                                 groupLen: Int = 16,
                                 mshrLen: Int = 8,
                                 tSize: Int = 64,
                                 verbosity: String = "low",
                                 components: String = "",
                                 printLog: Boolean = false,
                                 printMemLog: Boolean = false,
                                 printCLog: Boolean = false,
                                 cacheNWays: Int = 4,
                                 cacheNSets: Int = 8,
                                 cacheNState:Int = 8,
                                 cacheAddrLen:Int = 32,
                                 nSigs:Int = 10,
                                 actionLen: Int = 10 + 2,
                                 tbeSize:Int= 4

                               ) extends AccelParams {

  var xlen: Int = dataLen
  var ylen: Int = addrLen
  val tlen: Int = taskLen
  val glen: Int = groupLen
  val typeSize: Int = tSize
  val beats: Int = 0
  val mshrlen: Int = mshrLen
  val fType = dataLen match {
    case 64 => FType.D
    case 32 => FType.S
    case 16 => FType.H
  }

  //Cache
  val nways = cacheNWays
  val nsets = cacheNSets
  val nstates = cacheNState
  val addrlen = cacheAddrLen
  val nWords = 4

//  val nCommand = nCom
//  var comlen:Int = math.ceil(math.log(nCommand)/math.log(2)).toInt
//  val nSigs = nSigs

    def cacheBlockBytes: Int = nWords * (xlen >> 3) // 4 x 32 bits = 16B
  val cacheBlockBits = cacheBlockBytes << 3
//   def cacheBlockBytes: Int = xlen >> 3
  // Debugging dumps
  val log: Boolean = printLog
  val memLog: Boolean = printMemLog
  val clog: Boolean = printCLog
  val verb: String = verbosity
  val comp: String = components

}

/**
  * VCR parameters.
  * These parameters are used on VCR interfaces and modules.
  */
case class DandelionDCRParams(numCtrl: Int = 1,
                              numEvent: Int = 1,
                              numVals: Int = 2,
                              numPtrs: Int = 4,
                              numRets: Int = 0) {
  val nCtrl = numCtrl
  val nECnt = numEvent + numRets
  val nVals = numVals
  val nPtrs = numPtrs
  val regBits = 32
}

/**
  * DME parameters.
  * These parameters are used on DME interfaces and modules.
  */
case class DandelionDMEParams(numRead: Int = 1,
                              numWrite: Int = 1) {
  val nReadClients: Int = numRead
  val nWriteClients: Int = numWrite
  require(nReadClients > 0,
    s"\n\n[Dandelion] [DMEParams] nReadClients must be larger than 0\n\n")
  require(
    nWriteClients > 0,
    s"\n\n[Dandelion] [DMEParams] nWriteClients must be larger than 0\n\n")
}

class ParameterizedBundle(implicit p: Parameters) extends Bundle {
     override def cloneType = {
         try {
             this.getClass.getConstructors.head.newInstance(p).asInstanceOf[this.type]
           } catch {
          case e: java.lang.IllegalArgumentException =>
                throw new Exception("Unable to use ParamaterizedBundle.cloneType on " +
                 this.getClass + ", probably because " + this.getClass +
                                "() takes more than one argument.  Consider overriding " +
                                "cloneType() on " + this.getClass, e)
      }
     }
  }

/** Shell parameters. */
case class ShellParams(
                        val hostParams: AXIParams,
                        val memParams: AXIParams,
                        val vcrParams: DandelionDCRParams,
                        val dmeParams: DandelionDMEParams
                      )


case object DandelionConfigKey extends Field[DandelionAccelParams]

case object DCRKey extends Field[DandelionDCRParams]

case object DMEKey extends Field[DandelionDMEParams]

case object HostParamKey extends Field[AXIParams]

case object MemParamKey extends Field[AXIParams]


class WithAccelConfig(inParams: DandelionAccelParams = DandelionAccelParams())
  extends Config((site, here, up) => {
    // Core
    case DandelionConfigKey => inParams
  }
  )


/**
  * Please note that the dLen from WithSimShellConfig should be the same value as
  * AXI -- memParams:dataBits
  *
  * @param vcrParams
  * @param dmeParams
  * @param hostParams
  * @param memParams
  */
class WithTestConfig(vcrParams: DandelionDCRParams = DandelionDCRParams(),
                      dmeParams: DandelionDMEParams = DandelionDMEParams(),
                      hostParams: AXIParams = AXIParams(
                        addrBits = 16, dataBits = 64, idBits = 13, lenBits = 4),
                      memParams: AXIParams = AXIParams(
                        addrBits = 32, dataBits = 64, userBits = 5,
                        lenBits = 8, // limit to 16 beats, instead of 256 beats in AXI4
                        coherent = true),
                      nastiParams: NastiParameters = NastiParameters(dataBits = 32, addrBits = 32, idBits = 13))
  extends Config((site, here, up) => {
    // Core
    case DCRKey => vcrParams
    case DMEKey => dmeParams
    case HostParamKey => hostParams
    case MemParamKey => memParams
    case NastiKey => nastiParams
  }
  )



trait HasAccelParams {
  implicit val p: Parameters

  def accelParams: DandelionAccelParams = p(DandelionConfigKey)

  val xlen = accelParams.xlen
  val addrLen = accelParams.addrLen
  val bSize = accelParams.cacheBlockBits
  val ylen = accelParams.ylen
  val tlen = accelParams.tlen
  val glen = accelParams.glen
  val mshrLen = accelParams.mshrLen
  val typeSize = accelParams.typeSize
  val beats = typeSize / xlen
  val fType = accelParams.fType
  val log = accelParams.log
  val memLog = accelParams.memLog
  val clog = accelParams.clog
  val verb = accelParams.verb
  val comp = accelParams.comp
  val nSigs = accelParams.nSigs
  val tbeDepth = accelParams.tbeSize



}

trait HasAccelShellParams {
  implicit val p: Parameters

  def dcrParams: DandelionDCRParams = p(DCRKey)

  def dmeParams: DandelionDMEParams = p(DMEKey)

  def hostParams: AXIParams = p(HostParamKey)

  def memParams: AXIParams = p(MemParamKey)

  def nastiParams: NastiParameters = p(NastiKey)

}

abstract class AccelBundle(implicit val p: Parameters) extends DandelionParameterizedBundle()(p)
  with HasAccelParams

abstract class AXIAccelBundle(implicit val p: Parameters) extends DandelionGenericParameterizedBundle(p)
  with HasAccelParams

[0m2021.03.03 23:53:59 INFO  time: code lens generation in 1.9s[0m
Mar. 03, 2021 11:54:01 P.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 87
Exception in thread "pool-3-thread-5" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Exception in thread "pool-3-thread-6" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
[0m2021.03.04 00:00:25 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/config/Configs.scala[0m
Mar. 04, 2021 12:00:25 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 101
[0m2021.03.04 00:00:26 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/config/Configs.scala[0m
Mar. 04, 2021 12:00:27 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 102
Mar. 04, 2021 12:00:27 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 103
Mar. 04, 2021 12:00:29 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 105
Mar. 04, 2021 12:00:30 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 108
Mar. 04, 2021 12:00:30 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 109
Mar. 04, 2021 12:00:30 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 106
Mar. 04, 2021 12:00:32 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 116
Mar. 04, 2021 12:00:35 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 130
Exception in thread "pool-3-thread-7" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Mar. 04, 2021 12:00:48 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 153







Mar. 04, 2021 12:01:06 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 174
Exception in thread "pool-3-thread-8" java.lang.InterruptedException
	at scala.meta.internal.metals.FutureCancelToken.checkCanceled(FutureCancelToken.scala:29)
	at scala.meta.internal.pc.CompilerAccess.$anonfun$onCompilerJobQueue$1(CompilerAccess.scala:195)
	at scala.meta.internal.pc.CompilerJobQueue$Job.run(CompilerJobQueue.scala:103)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)


Mar. 04, 2021 12:02:07 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification

Mar. 04, 2021 12:03:29 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:04:05 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:08:16 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:10:55 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:11:21 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:11:56 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:12:41 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
Mar. 04, 2021 12:13:10 A.M. org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.03.04 00:18:05 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/FPU/SharedDiv.scala[0m
package memGen.fpu

import chisel3._
import chisel3.Module
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.interfaces._
import memGen.arbiters._
import util._zzz
import muxes._
import hardfloat._
import chipsalliance.rocketchip.config._
import memGen.config._

class SharedFPUIO(NumOps: Int, argTypes: Seq[Int])
                 (implicit p: Parameters) extends AccelBundle( )(p) {
  val InData = Vec(NumOps, Flipped(Decoupled(new FUReq(argTypes))))

  val OutData = Vec(NumOps, Output(new FUResp))

  override def cloneType = new SharedFPUIO(NumOps, argTypes).asInstanceOf[this.type]
}

class SharedFPU(NumOps: Int, PipeDepth: Int)(t: FType)
               (implicit val p: Parameters,
                name: sourcecode.Name,
                file: sourcecode.File)
  extends Module with HasAccelParams {
  override lazy val io = IO(new SharedFPUIO(NumOps, argTypes = List(xlen, xlen, xlen)))

  // Printf debugging
  val node_name       = name.value
  val module_name     = file.value.split("/").tail.last.split("\\.").head.capitalize
  val (cycleCount, _) = Counter(true.B, 32 * 1024)

  print(t.expWidth)
  // Arguments for function unit
  val argTypes = List(xlen, xlen, xlen)
  // The function unit
  val ds       = Module(new DivSqrtRecFN_small(t.expWidth, t.sigWidth, 0))
  //  Metadata queue associated with function unit
  val RouteQ   = Module(new Queue(UInt(tlen.W), PipeDepth))

  /**
    * Instantiating Arbiter module and connecting inputs to the output
    *
    * @note we fix the base size to 8
    */
  val in_arbiter = Module(new ArbiterTree(BaseSize = 2, NumOps = NumOps, new FUReq(argTypes), Locks = 1))
  val out_demux  = Module(new DeMuxTree(BaseSize = 2, NumOps = NumOps, new FUResp))

  //@todo fix the base size
  out_demux.io.input <> DontCare

  for (i <- 0 until NumOps) {
    in_arbiter.io.in(i) <> io.InData(i)
    io.OutData(i) <> out_demux.io.outputs(i)
  }

  // Declare metadata queue associated with function unit.
  // PipeDepth = Function unit pipeline stages
  // The buffering depth of RouteQ is the maximum number of FU executions
  // that can be outstanding.
  RouteQ.io.enq.valid := in_arbiter.io.out.valid & ds.io.inReady
  RouteQ.io.enq.bits := in_arbiter.io.out.bits.RouteID

  // Wire up arbiter ready to function unit and queue ready
  in_arbiter.io.out.ready := ds.io.inReady && RouteQ.io.enq.ready
  // Wire up arbiter to function unit. Direct params to function unit
  ds.io.inValid := in_arbiter.io.out.valid
  ds.io.sqrtOp := in_arbiter.io.out.bits.data("field2").data.orR
  ds.io.a := t.recode(in_arbiter.io.out.bits.data("field0").data)
  ds.io.b := t.recode(in_arbiter.io.out.bits.data("field1").data)
  //  ds.io.a := in_arbiter.io.out.bits.data("field0").data
  //  ds.io.b := in_arbiter.io.out.bits.data("field1").data
  ds.io.roundingMode := "b110".U(3.W)
  ds.io.detectTininess := 0.U(1.W)

  out_demux.io.enable := ds.io.outValid_div || ds.io.outValid_sqrt
  RouteQ.io.deq.ready := ds.io.outValid_div || ds.io.outValid_sqrt
  out_demux.io.input.data := fNFromRecFN(t.expWidth, t.sigWidth, ds.io.out)
  out_demux.io.input.RouteID := RouteQ.io.deq.bits
  out_demux.io.input.valid := ds.io.outValid_div || ds.io.outValid_sqrt
  // Use RouteQ value to demux the output of fn
  val x = fNFromRecFN(t.expWidth, t.sigWidth, ds.io.out)

}

package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 04, 2021 12:18:15 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 195
[0m2021.03.04 00:18:16 INFO  time: code lens generation in 1.48s[0m
[0m2021.03.04 00:18:35 INFO  shutting down Metals[0m
[0m2021.03.04 00:27:44 INFO  Started: Metals version 0.10.0 in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim' for client vscode 1.45.1.[0m
[0m2021.03.04 00:27:48 INFO  time: initialize in 3.88s[0m
[0m2021.03.04 00:27:48 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.04 00:27:48 ERROR org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:54)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.04 00:27:49 WARN  resetting database: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals.h2.db[0m
[0m2021.03.04 00:27:49 ERROR unable to setup persistent H2 database with AUTO_SERVER=false, falling back to in-memory database. This means you may be redundantly asked to execute 'Import build', even if it's not needed. Also, code navigation will not work for existing files in the .metals/readonly/ directory. To fix this problem, make sure you only have one running Metals server in the directory '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'.
org.flywaydb.core.internal.exception.FlywaySqlException: 
Unable to obtain connection from database (jdbc:h2:file:/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/.metals/metals;MV_STORE=false;AUTO_SERVER=TRUE) for user 'sa': Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SQL State  : HYC00
Error Code : 50100
Message    : Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]

	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:68)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
Caused by: org.h2.jdbc.JdbcSQLFeatureNotSupportedException: Feature not supported: "autoServerMode && (readOnly || fileLockMethod == NO || fileLockMethod == FS || inMemory)" [50100-200]
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:507)
	at org.h2.message.DbException.getJdbcSQLException(DbException.java:429)
	at org.h2.message.DbException.get(DbException.java:205)
	at org.h2.message.DbException.get(DbException.java:181)
	at org.h2.message.DbException.getUnsupportedException(DbException.java:269)
	at org.h2.engine.Database.open(Database.java:639)
	at org.h2.engine.Database.openDatabase(Database.java:307)
	at org.h2.engine.Database.<init>(Database.java:301)
	at org.h2.engine.Engine.openSession(Engine.java:74)
	at org.h2.engine.Engine.openSession(Engine.java:192)
	at org.h2.engine.Engine.createSessionAndValidate(Engine.java:171)
	at org.h2.engine.Engine.createSession(Engine.java:166)
	at org.h2.engine.Engine.createSession(Engine.java:29)
	at org.h2.engine.SessionRemote.connectEmbeddedOrServer(SessionRemote.java:340)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:173)
	at org.h2.jdbc.JdbcConnection.<init>(JdbcConnection.java:152)
	at org.h2.Driver.connect(Driver.java:69)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnectionFromDriver(DriverDataSource.java:325)
	at org.flywaydb.core.internal.jdbc.DriverDataSource.getConnection(DriverDataSource.java:289)
	at org.flywaydb.core.internal.jdbc.JdbcUtils.openConnection(JdbcUtils.java:59)
	at org.flywaydb.core.internal.jdbc.JdbcConnectionFactory.<init>(JdbcConnectionFactory.java:69)
	at org.flywaydb.core.Flyway.execute(Flyway.java:507)
	at org.flywaydb.core.Flyway.clean(Flyway.java:358)
	at scala.meta.internal.metals.Tables.migrateOrRestart(Tables.scala:123)
	at scala.meta.internal.metals.Tables.tryUrl(Tables.scala:111)
	at scala.meta.internal.metals.Tables.persistentConnection(Tables.scala:105)
	at scala.meta.internal.metals.Tables.tryNoAutoServer(Tables.scala:71)
	at scala.meta.internal.metals.Tables.tryAutoServer(Tables.scala:65)
	at scala.meta.internal.metals.Tables.connect(Tables.scala:37)
	at scala.meta.internal.metals.MetalsLanguageServer.initialized(MetalsLanguageServer.scala:862)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.lang.Thread.run(Thread.java:834)
[0m
[0m2021.03.04 00:27:50 WARN  Build server is not auto-connectable.[0m
[0m2021.03.04 00:27:52 WARN  no build tool detected in workspace '/run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.04 00:27:52 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
[0m2021.03.04 00:27:59 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
Mar. 04, 2021 12:28:00 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(8,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}

[0m2021.03.04 00:28:04 INFO  time: code lens generation in 10s[0m
[0m2021.03.04 00:28:27 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:28:30 INFO  time: code lens generation in 2.47s[0m
Mar. 04, 2021 12:28:42 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25
Mar. 04, 2021 12:28:45 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29
Mar. 04, 2021 12:28:46 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 33
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := 0.
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:28:48 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
[0m2021.03.04 00:28:49 INFO Mar. 04, 2021 12:28:49 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 45
 time: code lens generation in 1.38s[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:28:52 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
[0m2021.03.04 00:28:52 INFO  time: code lens generation in 1.57s[0m



Mar. 04, 2021 12:28:59 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 70



[0m2021.03.04 00:29:01 INFO  time: code lens generation in 1.25s[0m

Mar. 04, 2021 12:29:02 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 86

[0m2021.03.04 00:29:02 INFO  time: code lens generation in 1.32s[0m


[0m2021.03.04 00:29:03 INFO  time: code lens generation in 1.31s[0m


Mar. 04, 2021 12:29:26 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 102




[0m2021.03.04 00:30:16 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/memGen/src/main/scala/shell/DCR.scala[0mpackage memGen.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import memGen.config._
import memGen.util._
import memGen.interfaces.axi._


/** Register File.
 *
 * Six 32-bit register file.
 *
 * -------------------------------
 * Register description    | addr
 * -------------------------|-----
 * Control status register | 0x00
 * Cycle counter           | 0x04
 * Constant value          | 0x08
 * Vector length           | 0x0c
 * Input pointer lsb       | 0x10
 * Input pointer msb       | 0x14
 * Output pointer lsb      | 0x18
 * Output pointer msb      | 0x1c
 * -------------------------------
 *
 * ------------------------------
 * Control status register | bit
 * ------------------------------
 * Launch                  | 0
 * Finish                  | 1
 * ------------------------------
 */


/** VCRBase. Parametrize base class. */
abstract class DCRBase(implicit p: Parameters) extends DandelionParameterizedBundle()(p)

/** VCRMaster.
 *
 * This is the master interface used by VCR in the DandelionShell to control
 * the Core unit.
 */
class DCRMaster(implicit val p: Parameters) extends DCRBase with HasAccelShellParams {
  val vp = dcrParams
  val mp = memParams
  val launch = Output(Bool())
  val finish = Input(Bool())
  val ecnt = Vec(vp.nECnt, Flipped(ValidIO(UInt(vp.regBits.W))))
  val vals = Output(Vec(vp.nVals, UInt(vp.regBits.W)))
  val ptrs = Output(Vec(vp.nPtrs, UInt(mp.addrBits.W)))
}

/** VCRClient.
 *
 * This is the client interface used by the Core module to communicate
 * to the VCR in the DandelionShell.
 */
class DCRClient(implicit val p: Parameters) extends DCRBase with HasAccelShellParams {
  val vp = dcrParams
  val mp = memParams
  val launch = Input(Bool())
  val finish = Output(Bool())
  val ecnt = Vec(vp.nECnt, ValidIO(UInt(vp.regBits.W)))
  val vals = Input(Vec(vp.nVals, UInt(vp.regBits.W)))
  val ptrs = Input(Vec(vp.nPtrs, UInt(mp.addrBits.W)))
}

/** DTA Control Registers (DCR).
 *
 * This unit provides control registers (32 and 64 bits) to be used by a control'
 * unit, typically a host processor. These registers are read-only by the core
 * at the moment but this will likely change once we add support to general purpose
 * registers that could be used as event counters by the Core unit.
 */
class DCR(implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val dcr = new DCRMaster
  })

  val vp = dcrParams
  val mp = memParams
  val hp = hostParams

  // Write control (AW, W, B)
  val waddr = RegInit("h_ffff".U(hp.addrBits.W)) // init with invalid address
  val wdata = io.host.w.bits.data
  val sWriteAddress :: sWriteData :: sWriteResponse :: Nil = Enum(3)
  val wstate = RegInit(sWriteAddress)

  // read control (AR, R)
  val sReadAddress :: sReadData :: Nil = Enum(2)
  val rstate = RegInit(sReadAddress)
  val rdata = RegInit(0.U(vp.regBits.W))

  // registers
  val nPtrs = if (mp.addrBits == 32) vp.nPtrs else 2 * vp.nPtrs
  val nTotal = vp.nCtrl + vp.nECnt + vp.nVals + nPtrs

  val reg = Seq.fill(nTotal)(RegInit(0.U(vp.regBits.W)))
  val addr = Seq.tabulate(nTotal)(_ * 4)
  val reg_map = (addr zip reg) map { case (a, r) => a.U -> r }
  val eo = vp.nCtrl
  val vo = eo + vp.nECnt
  val po = vo + vp.nVals

  switch(wstate) {
    is(sWriteAddress) {
      when(io.host.aw.valid) {
        wstate := sWriteData
      }
    }
    is(sWriteData) {
      when(io.host.w.valid) {
        wstate := sWriteResponse
      }
    }
    is(sWriteResponse) {
      when(io.host.b.ready) {
        wstate := sWriteAddress
      }
    }
  }

  when(io.host.aw.fire()) {
    waddr := io.host.aw.bits.addr
  }

  io.host.aw.ready := wstate === sWriteAddress
  io.host.w.ready := wstate === sWriteData
  io.host.b.valid := wstate === sWriteResponse
  io.host.b.bits.resp := 0.U

  switch(rstate) {
    is(sReadAddress) {
      when(io.host.ar.valid) {
        rstate := sReadData
      }
    }
    is(sReadData) {
      when(io.host.r.ready) {
        rstate := sReadAddress
      }
    }
  }

  io.host.ar.ready := rstate === sReadAddress
  io.host.r.valid := rstate === sReadData
  io.host.r.bits.data := rdata
  io.host.r.bits.resp := 0.U

  when(io.dcr.finish) {
    reg(0) := "b_10".U
  }.elsewhen(io.host.w.fire() && addr(0).U === waddr) {
    reg(0) := wdata
  }

  for (i <- 0 until vp.nECnt) {
    when(io.dcr.ecnt(i).valid) {
      reg(eo + i) := io.dcr.ecnt(i).bits
    }.elsewhen(io.host.w.fire() && addr(eo + i).U === waddr) {
      reg(eo + i) := wdata
    }
  }

  for (i <- 0 until (vp.nVals + nPtrs)) {
    when(io.host.w.fire() && addr(vo + i).U === waddr) {
      reg(vo + i) := wdata
    }
  }

  when(io.host.ar.fire()) {
    rdata := MuxLookup(io.host.ar.bits.addr, 0.U, reg_map)
  }

  io.dcr.launch := reg(0)(0)

  for (i <- 0 until vp.nVals) {
    io.dcr.vals(i) := reg(vo + i)
  }

  if (mp.addrBits == 32) { // 32-bit pointers
    for (i <- 0 until nPtrs) {
      io.dcr.ptrs(i) := reg(po + i)
    }
  } else { // 64-bits pointers
    for (i <- 0 until (nPtrs / 2)) {
      io.dcr.ptrs(i) := Cat(reg(po + 2 * i + 1), reg(po + 2 * i))
    }
  }
}


[0m2021.03.04 00:30:40 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/test/scala/accel/DCRAccel.scala[0m
package test

import chisel3._
import chisel3.MultiIOModule
import dandelion.shell._
import chipsalliance.rocketchip.config._
import dandelion.GuardReader
import dandelion.config._
import dandelion.generator._
import dandelion.accel.{DandelionAccelDCRModule, DandelionAccelDebugModule, DandelionAccelModule}
import sim.shell._
import dandelion.shell._
import memGen.shell._
import memGen.config.{WithAccelConfig, WithTestConfig}

class DandelionSimDebugAccel(accelModule: () => DandelionAccelDCRModule, debugModule: () => DandelionAccelDebugModule)
                            (numPtrs: Int, numDbgs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                            (implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val sim_clock = IO(Input(Clock()))
  val sim_wait = IO(Output(Bool()))
  val sim_shell = Module(new AXISimShell)
  val shell = Module(new DandelionDebugShell(accelModule)(debugModule)
  (numPtrs = numPtrs, numDbgs = numDbgs, numVals = numVals,
    numRets = numRets, numEvents = numEvents, numCtrls = numCtrls))

  sim_shell.sim_clock := sim_clock
  sim_wait := sim_shell.sim_wait

  /**
    * @TODO: This is a bug from chisel otherwise, bulk connection should work here
    */
  sim_shell.mem.ar <> shell.io.mem.ar
  sim_shell.mem.aw <> shell.io.mem.aw
  sim_shell.mem.w <> shell.io.mem.w
  shell.io.mem.b <> sim_shell.mem.b
  shell.io.mem.r <> sim_shell.mem.r

  sim_shell.host.b <> shell.io.host.b
  sim_shell.host.r <> shell.io.host.r
  shell.io.host.ar <> sim_shell.host.ar
  shell.io.host.aw <> sim_shell.host.aw
  shell.io.host.w <> sim_shell.host.w
}


class DandelionSimDCRAccel(accelModule: () => memGenModule)
                          (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                          (implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val sim_clock = IO(Input(Clock()))
  val sim_wait = IO(Output(Bool()))
  val sim_shell = Module(new AXISimShell)
  val shell = Module(new memGenDCRCacheShell(accelModule)(numPtrs = numPtrs, numVals = numVals, numRets = numRets, numEvents = numEvents, numCtrls = numCtrls))

  sim_shell.sim_clock := sim_clock
  sim_wait := sim_shell.sim_wait

  /**
    * @TODO: This is a bug from chisel otherwise, bulk connection should work here
    */
  sim_shell.mem.ar <> shell.io.mem.ar
  sim_shell.mem.aw <> shell.io.mem.aw
  sim_shell.mem.w <> shell.io.mem.w
  shell.io.mem.b <> sim_shell.mem.b
  shell.io.mem.r <> sim_shell.mem.r

  sim_shell.host.b <> shell.io.host.b
  sim_shell.host.r <> shell.io.host.r
  shell.io.host.ar <> sim_shell.host.ar
  shell.io.host.aw <> sim_shell.host.aw
  shell.io.host.w <> sim_shell.host.w
}


/**
  * Main object for compatible DCR accelerator with Dandelion generator
  *
  * @TODO: The option manager needs to be added instead of parsing input arguments
  *        this is not a clean way to pass arguments
  */
object DandelionSimDCRAccelMain extends App {

  //These are default values for DCR
  var num_ptrs = 0
  var num_vals = 0
  var num_returns = 1
  var num_events = 1
  var num_ctrls = 1

  /**
    * Make sure accel name is added to TestDCRAccel class
    */
  var accel_name = "memGenAccel"

  /**
    * Accel config values
    */
  var data_len = 64
  var print_log = true
  var cache_log = false

  args.sliding(2, 2).toList.collect {
    case Array("--accel-name", argAccel: String) => accel_name = argAccel
    case Array("--num-ptrs", argPtrs: String) => num_ptrs = argPtrs.toInt
    case Array("--num-vals", argVals: String) => num_vals = argVals.toInt
    case Array("--num-rets", argRets: String) => num_returns = argRets.toInt
    case Array("--num-events", argEvent: String) => num_events = argEvent.toInt
    case Array("--num-ctrls", argCtrl: String) => num_ctrls = argCtrl.toInt
    case Array("--data-len", dlen: String) => data_len = dlen.toInt
    case Array("--print-log", printLog: String) => print_log = printLog.toBoolean
    case Array("--cache-log", cacheLog: String) => cache_log = cacheLog.toBoolean
  }

  /**
    * @note make sure for simulation dataLen is equal to 64
    *       Pass generated accelerator to TestAccel
    */
  implicit val p =
    new WithSimShellConfig(dLen = data_len, pLog = print_log, cLog = cache_log)(
      nPtrs = num_ptrs, nVals = num_vals, nRets = num_returns, nEvents = num_events, nCtrls = num_ctrls) ++
      new memGen.config.WithAccelConfig() ++
      new WithTestConfig()
  chisel3.Driver.execute(args.take(4),
    () => new DandelionSimDCRAccel(() => DandelionTestDCRAccel(accel_name))(
      numPtrs = num_ptrs, numVals = num_vals, numRets = num_returns, numEvents = num_events, numCtrls = num_ctrls))
}


/**
  * Main object for compatible DCR accelerator with Dandelion generator
  *
  * @TODO: The option manager needs to be added instead of parsing input arguments
  *        this is not a clean way to pass arguments
  */
object DandelionSimDebugAccelMain extends App {

  //These are default values for DCR
  var num_ptrs = 0
  var num_dbgs = 1
  var num_vals = 0
  var num_returns = 1
  var num_events = 1
  var num_ctrls = 1

  /**
    * Make sure accel name is added to TestDCRAccel class
    */
  var accel_name = "test09"

  /**
    * Accel config values
    */
  var data_len = 64
  var print_log = true
  var cache_log = false
  var bore_ids = List[Int]()

  args.sliding(2, 2).toList.collect {
    case Array("--accel-name", argAccel: String) => accel_name = argAccel
    case Array("--num-ptrs", argPtrs: String) => num_ptrs = argPtrs.toInt
    case Array("--num-dbgs", argDbgs: String) => num_dbgs = argDbgs.toInt
    case Array("--num-vals", argVals: String) => num_vals = argVals.toInt
    case Array("--num-rets", argRets: String) => num_returns = argRets.toInt
    case Array("--num-events", argEvent: String) => num_events = argEvent.toInt
    case Array("--num-ctrls", argCtrl: String) => num_ctrls = argCtrl.toInt
    case Array("--data-len", dlen: String) => data_len = dlen.toInt
    case Array("--print-log", printLog: String) => print_log = printLog.toBoolean
    case Array("--cache-log", cacheLog: String) => cache_log = cacheLog.toBoolean
    case Array("--bore-ids", boreids: String) => bore_ids = boreids.split(',').map(_.toInt).toList
  }

  /**
    * @note make sure for simulation dataLen is equal to 64
    *       Pass generated accelerator to TestAccel
    */
  implicit val p =
    new WithDebugSimShellConfig(dLen = data_len, pLog = print_log, cLog = cache_log)(
      nPtrs = num_ptrs, nVals = num_vals, nRets = num_returns, nEvents = num_events, nCtrls = num_ctrls, nDbgs = num_dbgs)

  lazy val accel_module = DandelionTestDebugDCRAccel(accel_name, num_dbgs, bore_ids)
  chisel3.Driver.execute(args.take(4) ++ List("--full-stacktrace"),
    () => new DandelionSimDebugAccel(accel_module._1, accel_module._2)
    (numPtrs = num_ptrs, numDbgs = num_dbgs, numVals = num_vals, numRets = num_returns, numEvents = num_events, numCtrls = num_ctrls))

}


/**
  * This is the F1 accel shell to run on AWS
  * The difference between F1 shell and the other shells is AXILite interface
  * For F1 we have used a custom interface instead of AXI lite and the memory
  * is mapped to sepecific addresses.
  * For more details please read Dandelion-Tutorial
  */


/**
  * Getting verilog file for SpAccel
  */

import java.io.{File, FileWriter}

object DCRAccelMain extends App {

  //These are default values for DCR
  var num_ptrs = 0
  var num_dbgs = 1
  var num_vals = 0
  var num_returns = 1
  var num_events = 1
  var num_ctrls = 1

  /**
    * Make sure accel name is added to TestDCRAccel class
    */
  var accel_name = "test09"

  /**
    * Accel config values
    */
  var data_len = 64
  var print_log = true
  var cache_log = false
  var bore_ids = List[Int]()

  args.sliding(2, 2).toList.collect {
    case Array("--accel-name", argAccel: String) => accel_name = argAccel
    case Array("--num-ptrs", argPtrs: String) => num_ptrs = argPtrs.toInt
    case Array("--num-dbgs", argDbgs: String) => num_dbgs = argDbgs.toInt
    case Array("--num-vals", argVals: String) => num_vals = argVals.toInt
    case Array("--num-rets", argRets: String) =
> num_returns = argRets.toInt
    case Array("--num-events", argEvent: String) => num_events = argEvent.toInt
    case Array("--num-ctrls", argCtrl: String) => num_ctrls = argCtrl.toInt
    case Array("--data-len", dlen: String) => data_len = dlen.toInt
    case Array("--print-log", printLog: String) => print_log = printLog.toBoolean
    case Array("--cache-log", cacheLog: String) => cache_log = cacheLog.toBoolean
    case Array("--bore-ids", boreids: String) => bore_ids = boreids.split(',').map(_.toInt).toList
  }

  val dir = new File("RTL/DCRAccel");
  dir.mkdirs
  /**
    * @note make sure for simulation dataLen is equal to 64
    *       Pass generated accelerator to TestAccel
    */
  implicit val p =
    new WithDe10ShellConfig(dLen = data_len, pLog = print_log)(
      nPtrs = num_ptrs, nVals = num_vals, nRets = num_returns, nEvents = num_events, nCtrls = num_ctrls, nDbgs = num_dbgs)

  lazy val accel_module = DandelionTestDebugDCRAccel(accel_name, num_dbgs, bore_ids)

  val chirrtl = firrtl.Parser.parse(chisel3.Driver.emit(
    () => new DandelionDebugFPGAShell(accel_module._1)(accel_module._2)
    (numPtrs = num_ptrs, numDbgs = num_dbgs, numVals = num_vals, numRets = num_returns, numEvents = num_events, numCtrls = num_ctrls)))

  val verilogFile = new File(dir, s"${chirrtl.main}.v")
  val verilogWriter = new FileWriter(verilogFile)
  val compileResult = (new firrtl.VerilogCompiler).compileAndEmit(firrtl.CircuitState(chirrtl, firrtl.ChirrtlForm))
  val compiledStuff = compileResult.getEmittedCircuit
  verilogWriter.write(compiledStuff.value)
  verilogWriter.close()
}

/**
  * This is the F1 accel shell to run on AWS
  * The difference between F1 shell and the other shells is AXILite interface
  * For F1 we have used a custom interface instead of AXI lite and the memory
  * is mapped to sepecific addresses.
  * For more details please read Dandelion-Tutorial
  */

object DandelionF1AccelMain extends App {

  //These are default values for DCR
  var num_ptrs = 0
  var num_dbgs = 1
  var num_vals = 0
  var num_returns = 1
  var num_events = 1
  var num_ctrls = 1

  /**
    * Make sure accel name is added to TestDCRAccel class
    */
  var accel_name = "test09"

  /**
    * Accel config values
    */
  var data_len = 64
  var print_log = true
  var cache_log = false
  var bore_ids = List[Int]()

  args.sliding(2, 2).toList.collect {
    case Array("--accel-name", argAccel: String) => accel_name = argAccel
    case Array("--num-ptrs", argPtrs: String) => num_ptrs = argPtrs.toInt
    case Array("--num-dbgs", argDbgs: String) => num_dbgs = argDbgs.toInt
    case Array("--num-vals", argVals: String) => num_vals = argVals.toInt
    case Array("--num-rets", argRets: String) => num_returns = argRets.toInt
    case Array("--num-events", argEvent: String) => num_events = argEvent.toInt
    case Array("--num-ctrls", argCtrl: String) => num_ctrls = argCtrl.toInt
    case Array("--data-len", dlen: String) => data_len = dlen.toInt
    case Array("--print-log", printLog: String) => print_log = printLog.toBoolean
    case Array("--cache-log", cacheLog: String) => cache_log = cacheLog.toBoolean
    case Array("--bore-ids", boreids: String) => bore_ids = boreids.split(',').map(_.toInt).toList
  }

  val dir = new File("RTL/" + accel_name);
  dir.mkdirs
  /**
    * @note make sure for simulation dataLen is equal to 64
    *       Pass generated accelerator to TestAccel
    */
  implicit val p =
    new WithF1ShellConfig(dLen = data_len, pLog = print_log)(
      nPtrs = num_ptrs, nVals = num_vals, nRets = num_returns, nEvents = num_events, nCtrls = num_ctrls, nDbgs = num_dbgs)

  lazy val accel_module = DandelionTestDebugDCRAccel(accel_name, num_dbgs, bore_ids)

  val chirrtl = firrtl.Parser.parse(chisel3.Driver.emit(
    () => new F1Shell(accel_module._1)(accel_module._2)
    (nPtrs = num_ptrs, nDbgs = num_dbgs, nVals = num_vals, numRets = num_returns, numEvents = num_events, numCtrls = num_ctrls)))

  val verilogFile = new File(dir, s"${chirrtl.main}.v")
  val verilogWriter = new FileWriter(verilogFile)
  val compileResult = (new firrtl.VerilogCompiler).compileAndEmit(firrtl.CircuitState(chirrtl, firrtl.ChirrtlForm))
  val compiledStuff = compileResult.getEmittedCircuit
  verilogWriter.write(compiledStuff.value)
  verilogWriter.close()
}

[0m2021.03.04 00:30:43 INFO  time: code lens generation in 2.35s[0m


Mar. 04, 2021 12:31:04 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 132
[0m2021.03.04 00:31:08 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}





[0m2021.03.04 00:31:34 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(8,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}





[0m2021.03.04 00:31:53 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


Mar. 04, 2021 12:32:16 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 172
Mar. 04, 2021 12:32:24 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 180
Mar. 04, 2021 12:32:27 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 186
Mar. 04, 2021 12:32:35 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 214
Mar. 04, 2021 12:32:35 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 217
Mar. 04, 2021 12:32:35 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 219
Mar. 04, 2021 12:32:35 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 222

Mar. 04, 2021 12:32:38 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 237


Mar. 04, 2021 12:32:41 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 245


Mar. 04, 2021 12:32:42 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 253

Mar. 04, 2021 12:32:43 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 252
Mar. 04, 2021 12:32:43 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 254
Mar. 04, 2021 12:32:43 A.M. scala.meta.internal.pc.CompilerAccess retryWithCleanCompiler
INFO: compiler crashed due to an error in the Scala compiler, retrying with new compiler instance.
Mar. 04, 2021 12:32:43 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 256
Mar. 04, 2021 12:32:44 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 266

[0m2021.03.04 00:32:44 INFO  time: code lens generation in 1.06s[0m

Mar. 04, 2021 12:32:45 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 267
Mar. 04, 2021 12:32:45 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 272
Mar. 04, 2021 12:32:45 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 271


Mar. 04, 2021 12:32:46 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 283
Mar. 04, 2021 12:32:46 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 287
Mar. 04, 2021 12:32:46 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 286


Mar. 04, 2021 12:32:47 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 292

Mar. 04, 2021 12:32:48 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 298

[0m2021.03.04 00:32:56 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).bits := 0.U
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:32:59 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
[0m2021.03.04 00:33:35 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).bits := 0.U
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /** 
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


Mar. 04, 2021 12:33:59 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 325
Mar. 04, 2021 12:33:59 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 324
Mar. 04, 2021 12:34:01 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 337
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).bits := 0.U
      // vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /** 
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:34:05 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
Mar. 04, 2021 12:34:11 A.M. scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Frun%2Fuser%2F1000%2Fgvfs%2Fsftp%3Ahost%3Dserver-01%2Flocal-scratch%2Flocalhome%2Fasedagha%2Fgits%2Fmuir-sim%2Fhardware%2Fchisel%2Fsrc%2Fmain%2Fscala%2Fshell%2FmemGenDCRCacheShell.scala:1: error: illegal character '\u0000'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
^
file%3A%2F%2F%2Frun%2Fuser%2F1000%2Fgvfs%2Fsftp%3Ahost%3Dserver-01%2Flocal-scratch%2Flocalhome%2Fasedagha%2Fgits%2Fmuir-sim%2Fhardware%2Fchisel%2Fsrc%2Fmain%2Fscala%2Fshell%2FmemGenDCRCacheShell.scala:1: error: illegal character '\u0000'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    
^
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:23)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.Reporter.syntaxError(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter.syntaxError$(Reporter.scala:25)
	at scala.meta.internal.tokenizers.Reporter$$anon$1.syntaxError(Reporter.scala:33)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchOther$1(LegacyScanner.scala:529)
	at scala.meta.internal.tokenizers.LegacyScanner.fetchToken(LegacyScanner.scala:533)
	at scala.meta.internal.tokenizers.LegacyScanner.nextToken(LegacyScanner.scala:251)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1107)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:157)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:895)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:336)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.tokenizers.Api$XtensionTokenizeInputLike.tokenize(Api.scala:14)
	at scala.meta.internal.parsers.ScalametaParser.scannerTokens$lzycompute(ScalametaParser.scala:239)
	at scala.meta.internal.parsers.ScalametaParser.scannerTokens(ScalametaParser.scala:239)
	at scala.meta.internal.parsers.ScalametaParser.<init>(ScalametaParser.scala:154)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5039)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.04 00:34:11 INFO  time: code lens generation in 1.46s[0m
Mar. 04, 2021 12:34:50 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 386


Mar. 04, 2021 12:34:53 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 397

Mar. 04, 2021 12:34:58 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 403

Mar. 04, 2021 12:34:59 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 406
Mar. 04, 2021 12:34:59 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 408





package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 04, 2021 12:36:19 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 443
Mar. 04, 2021 12:36:19 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 445
Mar. 04, 2021 12:36:19 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 447
Mar. 04, 2021 12:36:19 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 446
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 04, 2021 12:36:23 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 461
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.datdataValsaVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.04 00:36:54 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/cacheShell/memGenCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 04, 2021 12:36:58 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 468
Mar. 04, 2021 12:37:03 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didSave",
  "params": {
    "textDocument": {
      "uri": "file:///run/user/1000/gvfs/sftp%3Ahost%3Dserver-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala"
    },
    "text": "package dandelion.shell\n\nimport chisel3._\nimport chisel3.util._\nimport chipsalliance.rocketchip.config._\nimport dandelion.config._\nimport dandelion.interfaces.{ControlBundle, DataBundle}\nimport dandelion.interfaces.axi._\nimport dandelion.memory.cache._\nimport dandelion.accel._\nimport memGen.memory._\nimport memGen.shell._\n\nclass memGenDCRCacheShell [T \u003c: memGenModule](accelModule: () \u003d\u003e T)\n                                             (numPtrs: Int \u003d 0, numVals: Int \u003d 6, numRets: Int \u003d 0, numEvents: Int \u003d 0, numCtrls: Int \u003d 0)\n                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {\n  val io \u003d IO(new Bundle {\n    val host \u003d new AXILiteClient(hostParams)\n    val mem \u003d new AXIMaster(memParams)\n  })\n\n\n  val numInputs  \u003d 3\n  // comment test\n\n  val regBits \u003d dcrParams.regBits\n  val ptrBits \u003d regBits * 2\n\n  val vcr \u003d Module(new DCR)\n\n  val accel \u003d Module(accelModule())\n\n  val sIdle :: sBusy :: sFlush :: sDone :: Nil \u003d Enum(4)\n\n  val state \u003d RegInit(sIdle)\n  val cycles \u003d RegInit(0.U(regBits.W))\n  val cnt \u003d RegInit(0.U(regBits.W))\n  val last \u003d state \u003d\u003d\u003d sDone\n  val is_busy \u003d state \u003d\u003d\u003d sBusy\n\n  when(state \u003d\u003d\u003d sIdle) {\n    cycles :\u003d 0.U\n  }.elsewhen(state \u003d/\u003d sFlush) {\n    cycles :\u003d cycles + 1.U\n  }\n\n  /**\n    * Connecting event controls and return values\n    * Event zero always contains the cycle count\n    */\n\n  if (accel.RetsOut.size \u003e 0) {\n    for (i \u003c- 1 to accel.RetsOut.size) {\n      // vcr.io.dcr.ecnt(i).bits :\u003d accel.io.out.bits.data(s\"field${i - 1}\").data\n      // vcr.io.dcr.ecnt(i).valid :\u003d accel.io.out.valid\n    }\n    \n  }\n\n vcr.io.dcr.ecnt(0).valid :\u003d last\n vcr.io.dcr.ecnt(0).bits :\u003d cycles\n\n  /**\n    * @note This part needs to be changes for each function\n    */\n    val (nextChunk,_) \u003d Counter(accel.io.in.fire, 1000)\n    val DataReg \u003d Reg(Vec(numVals, new DataBundle))\n    val (cycle,stopSim) \u003d Counter(true.B, 200)\n\n  val vals \u003d Seq.tabulate(numVals) { i \u003d\u003e RegEnable(next \u003d vcr.io.dcr.vals(i), init \u003d 0.U(ptrBits.W), enable \u003d  (state \u003d\u003d\u003d sIdle)) }\n  val ptrs \u003d Seq.tabulate(1) { i \u003d\u003e RegEnable(next \u003d vcr.io.dcr.ptrs(i), init \u003d 0.U(ptrBits.W), enable \u003d  (state \u003d\u003d\u003d sIdle)) }\n\n\n//  val DataQueue \u003d for (i \u003c- 0 until numInputs) yield {\n//    val DQ \u003d Module( new Queue( DataBundle(vals(i-numPtrs)), entries \u003d numVals/numInputs))\n//    DQ\n//  }\n\n  for (i \u003c- 0 until numVals) {\n    if( i % 3 \u003d\u003d 1 )\n      DataReg(i) :\u003d DataBundle(vals(i) + ptrs(0))\n    else\n     DataReg(i) :\u003d DataBundle(vals(i) )\n  }\n\n  for (i \u003c- 0 until numInputs) {\n    accel.io.in.bits.dataVals(s\"field${i}\") :\u003d DataReg(nextChunk * numInputs.U + i.U)\n  }\n\n  accel.io.in.bits.enable :\u003d ControlBundle.active()\n  accel.io.in.valid :\u003d false.B\n  accel.io.out.ready :\u003d is_busy\n\n\n  switch(state) {\n    is(sIdle) {\n      when(vcr.io.dcr.launch) {\n        printf(p\"\\nVals: \")\n        vals.zipWithIndex.foreach(t \u003d\u003e printf(p\"val(${t._2}): ${t._1}, \"))\n        printf(p\"\\n\")\n        state :\u003d sBusy\n      }\n    }\n    is(sBusy) {\n      when(accel.io.in.fire() ){\n        printf(p\"\\nVals: \")\n        vals.zipWithIndex.foreach(t \u003d\u003e printf(p\"val(${t._2}): ${t._1}, \"))\n        printf(p\"\\n\")\n      }\n        accel.io.in.valid :\u003d true.B\n        when(nextChunk * numInputs.U \u003e numVals.U) {\n          state :\u003d sDone\n        }\n    }\n\n    is(sDone) {\n      when(stopSim) {\n        state :\u003d sIdle\n      }\n    }\n  }\n\n  vcr.io.dcr.finish :\u003d last \u0026 stopSim\n  io.mem \u003c\u003e accel.io.mem\n  io.host \u003c\u003e vcr.io.host\n\n}\n\n"
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.NoSuchFileException: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala
	at java.base/sun.nio.fs.UnixException.translateToIOException(UnixException.java:92)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:111)
	at java.base/sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:116)
	at java.base/sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:219)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:371)
	at java.base/java.nio.file.Files.newByteChannel(Files.java:422)
	at java.base/java.nio.file.Files.readAllBytes(Files.java:3206)
	at scala.meta.internal.io.PlatformFileIO$.slurp(PlatformFileIO.scala:45)
	at scala.meta.internal.io.FileIO$.slurp(FileIO.scala:24)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionAbsolutePath.toInput(CommonMtagsEnrichments.scala:411)
	at scala.meta.internal.metals.MetalsLanguageServer.didSave(MetalsLanguageServer.scala:1071)
	... 16 more

package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      // vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


[0m2021.03.04 00:37:04 INFO  time: code lens generation in 1.11s[0m







Mar. 04, 2021 12:37:12 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 506
Mar. 04, 2021 12:37:14 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 516

[0m2021.03.04 00:37:15 INFO  time: code lens generation in 2.1s
[0m

[0m2021.03.04 00:37:15 INFO  time: code lens generation in 1.49s[0m



[0m2021.03.04 00:37:16 INFO  time: code lens generation in 1.65s[0m





Mar. 04, 2021 12:37:56 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "conflictResolution:/run/user/1000/gvfs/sftp%3Ahost%3Dserver-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala?%7B%22scheme%22%3A%22file%22%7D"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1128)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:628)
	at java.base/java.lang.Thread.run(Thread.java:834)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor10.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.FileSystemNotFoundException: Provider "conflictResolution" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:97)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:445)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:442)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:982)
	... 15 more



[0m2021.03.04 00:38:05 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      // vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      // vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := false.B
    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
Mar. 04, 2021 12:38:23 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 572
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.junctions._
import dandelion.accel._
import memGen.memory.cache._
import memGen.shell._




class memGenAccel ( PtrsIn: Seq[Int] = List(),
                               ValsIn: Seq[Int] = List(64, 64, 64),
                               RetsOut: Seq[Int] = List(16,32,256))
                             (implicit p:Parameters) extends  memGenModule (PtrsIn, ValsIn, RetsOut){

  val accel = Module (new memGenTopLevel())

//  val ArgSplitter = Module(new SplitCallDCR(ptrsArgTypes = List(1, 1, 1, 1), valsArgTypes = List()))
//  ArgSplitter.io.In <> io.in

  accel.io.instruction.bits.inst := io.in.bits.dataVals("field0").asUInt()
  accel.io.instruction.bits.addr := io.in.bits.dataVals("field1").asUInt()
  accel.io.instruction.bits.data := io.in.bits.dataVals("field2").asTypeOf(UInt((accelParams.cacheBlockBits).W))

 
   io.out <> DontCare

  io.out.bits.data("field0").data := accel.io.resp.bits.inst
  io.out.bits.data("field1").data := accel.io.resp.bits.addr
  io.out.bits.data("field2").data := accel.io.resp.bits.data

  // io.out.bits.data("field0").asControlBundle()
  // io.out.bits.data("field1").asControlBundle()
  // io.out.bits.data("field2").asControlBundle()
  io.out.valid := accel.io.resp.valid

  accel.io.resp.ready := io.out.ready


//  ArgSplitter.io.Out.enable.bits.debug := false.B
//  ArgSplitter.io.Out.enable.bits.taskID := 0.U
//  ArgSplitter.io.Out.enable.bits.control := accel.io.instruction.ready

  accel.io.instruction.valid := io.in.valid
  // io.out <> DontCare

  io.in.ready := accel.io.instruction.ready
  io.mem <> accel.io.mem

}
[0m2021.03.04 00:38:28 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/DandelionShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._

/** Register File.
 *
 * Six 32-bit register file.
 *
 * -------------------------------
 * Register description    | addr
 * -------------------------|-----
 * Control status register | 0x00
 * Cycle counter           | 0x04
 * Constant value          | 0x08
 * Vector length           | 0x0c
 * Input pointer lsb       | 0x10
 * Input pointer msb       | 0x14
 * Output pointer lsb      | 0x18
 * Output pointer msb      | 0x1c
 * -------------------------------
 *
 * ------------------------------
 * Control status register | bit
 * ------------------------------
 * Launch                  | 0
 * Finish                  | 1
 * ------------------------------
 */


/*
+------------------+                          +-----------------+
|                  | f(bits)+--------+        |                 |
|   DMEReadMaster  +------->+Buffers +-------->DMEWriteMaster   |
|                  |        +--------+        |                 |
+------------------+                          +-----------------+

 */

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */

/**
 *
 * @param p
 */
class DandelionVTAShell(implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val vcr = Module(new DCR)
  val dmem = Module(new DME)

  val buffer = Module(new Queue(dmem.io.dme.rd(0).data.bits.cloneType, 40))

  val sIdle :: sReq :: sBusy :: Nil = Enum(3)
  val Rstate = RegInit(sIdle)
  val Wstate = RegInit(sIdle)

  val cycle_count = new Counter(2000)

  when(Rstate =/= sIdle) {
    cycle_count.inc()
  }


  vcr.io.dcr.ecnt(0.U).bits := cycle_count.value

  // Read state machine
  switch(Rstate) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        cycle_count.value := 0.U
        Rstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.rd(0).cmd.fire()) {
        Rstate := sBusy
      }
    }
  }
  // Write state machine
  switch(Wstate) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        Wstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.wr(0).cmd.fire()) {
        Wstate := sBusy
      }
    }
  }

  dmem.io.dme.rd(0).cmd.bits.addr := vcr.io.dcr.ptrs(0)
  dmem.io.dme.rd(0).cmd.bits.len := vcr.io.dcr.vals(1)
  dmem.io.dme.rd(0).cmd.valid := false.B

  dmem.io.dme.wr(0).cmd.bits.addr := vcr.io.dcr.ptrs(2)
  dmem.io.dme.wr(0).cmd.bits.len := vcr.io.dcr.vals(1)
  dmem.io.dme.wr(0).cmd.valid := false.B

  when(Rstate === sReq) {
    dmem.io.dme.rd(0).cmd.valid := true.B
  }

  when(Wstate === sReq) {
    dmem.io.dme.wr(0).cmd.valid := true.B
  }

  // Final
  val last = Wstate === sBusy && dmem.io.dme.wr(0).ack
  vcr.io.dcr.finish := last
  vcr.io.dcr.ecnt(0).valid := last

  when(dmem.io.dme.wr(0).ack) {
    Rstate := sIdle
    Wstate := sIdle
  }


  buffer.io.enq <> dmem.io.dme.rd(0).data
  buffer.io.enq.bits := dmem.io.dme.rd(0).data.bits + vcr.io.dcr.vals(0)
  dmem.io.dme.wr(0).data <> buffer.io.deq

  io.mem <> dmem.io.mem
  io.host <> vcr.io.host

}

class DandelionF1DTAShell(implicit val p: Parameters) extends MultiIOModule with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new ConfigBusMaster(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val dcr = Module(new DCRF1)
  val dmem = Module(new DME)

  val buffer = Module(new Queue(dmem.io.dme.rd(0).data.bits.cloneType, 40))

  val sIdle :: sReq :: sBusy :: Nil = Enum(3)
  val Rstate = RegInit(sIdle)
  val Wstate = RegInit(sIdle)

  val cycle_count = new Counter(2000)

  when(Rstate =/= sIdle) {
    cycle_count.inc()
  }


  dcr.io.dcr.ecnt(0.U).bits := cycle_count.value

  // Read state machine
  switch(Rstate) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        cycle_count.value := 0.U
        Rstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.rd(0).cmd.fire()) {
        Rstate := sBusy
      }
    }
  }
  // Write state machine
  switch(Wstate) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        Wstate := sReq
      }
    }
    is(sReq) {
      when(dmem.io.dme.wr(0).cmd.fire()) {
        Wstate := sBusy
      }
    }
  }

  dmem.io.dme.rd(0).cmd.bits.addr := dcr.io.dcr.ptrs(0)
  dmem.io.dme.rd(0).cmd.bits.len := dcr.io.dcr.vals(1)
  dmem.io.dme.rd(0).cmd.valid := false.B

  dmem.io.dme.wr(0).cmd.bits.addr := dcr.io.dcr.ptrs(1)
  dmem.io.dme.wr(0).cmd.bits.len := dcr.io.dcr.vals(1)
  dmem.io.dme.wr(0).cmd.valid := false.B

  when(Rstate === sReq) {
    dmem.io.dme.rd(0).cmd.valid := true.B
  }

  when(Wstate === sReq) {
    dmem.io.dme.wr(0).cmd.valid := true.B
  }

  // Final
  val last = Wstate === sBusy && dmem.io.dme.wr(0).ack
  dcr.io.dcr.finish := last
  dcr.io.dcr.ecnt(0).valid := last

  when(dmem.io.dme.wr(0).ack) {
    Rstate := sIdle
    Wstate := sIdle
  }


  buffer.io.enq <> dmem.io.dme.rd(0).data
  buffer.io.enq.bits := dmem.io.dme.rd(0).data.bits + dcr.io.dcr.vals(0)
  dmem.io.dme.wr(0).data <> buffer.io.deq

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

}

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionCacheShell[T <: DandelionAccelModule](accelModule: () => T)
                                                    (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                    (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  //val cache = Module(new SimpleCache(debug = true))
  val cache = Module(new ReferenceCache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.Returns.size > 0) {
    for (i <- 1 to accel.Returns.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- numPtrs until numPtrs + numVals) {
    accel.io.in.bits.data(s"field${i}") := DataBundle(ptrs(i))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := state === sFlush

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  io.mem <> cache.io.mem
  io.host <> vcr.io.host

}


/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionDCRCacheShell[T <: DandelionAccelDCRModule](accelModule: () => T)
                                                          (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                          (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  //val cache = Module(new SimpleCache(debug = true))
  val cache = Module(new ReferenceCache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }
  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i - numPtrs))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := false.B

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      cache.io.cpu.flush := true.B
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  io.mem <> cache.io.mem
  io.host <> vcr.io.host

}

/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input Ptrs for the accelerator
 * @param numVals     Number of input Vals for the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 * @tparam T
 */
class DandelionDCRShell[T <: DandelionAccelDCRModule](accelModule: () => T)
                                                     (numPtrs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                                                     (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)
  val dme = Module(new DME)
  val cache = Module(new DMECache())

  val accel = Module(accelModule())

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  vcr.io.dcr.ecnt(0).valid := last
  vcr.io.dcr.ecnt(0).bits := cycles

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
    }
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }
  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i - numPtrs))
  }

  accel.io.in.bits.enable := ControlBundle.active()


  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.abort := false.B
  cache.io.cpu.flush := state === sFlush

  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): ${t._1}, "))
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache.io.cpu.flush_done) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  vcr.io.dcr.finish := last

  //io.mem <> cache.io.mem

  dme.io.dme.rd(0) <> cache.io.mem.rd
  dme.io.dme.wr(0) <> cache.io.mem.wr

  io.mem <> dme.io.mem
  io.host <> vcr.io.host

}


/* Receives a counter value as input. Waits for N cycles and then returns N + const as output */
/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input ptrs for the accelerator
 * @param numVals     Number of input values to the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 */
class DandelionDebugShell(accelModule: () => DandelionAccelDCRModule)
                         (debugModule: () => DandelionAccelDebugModule)
                         (numPtrs: Int, numDbgs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                         (implicit val p: Parameters) extends Module with HasAccelParams with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits

  /**
   * If xlen is 64bit, and vcr registers are 32bits then
   * ptrs are lo and hi
   */
  val ptrBits =
    if (xlen / regBits == 2)
      regBits * 2
    else
      regBits


  val dcr = Module(new DCR)
  val dmem = Module(new DME())
  val cache = Module(new DMECache())


  val accel = Module(accelModule())
  def isDebugger() = { numDbgs > 0}
  val debug_module = if (numDbgs > 0) Some(Module(debugModule())) else None

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp
  cache.io.cpu.abort := false.B

  /**
   * Connecting cache to DME
   */
  dmem.io.dme.rd(0) <> cache.io.mem.rd
  dmem.io.dme.wr(0) <> cache.io.mem.wr

  /**
   * TODO: make enable dependent on logic
   */
  if(isDebugger()) debug_module.get.io.enableNode.foreach(_ := true.B)

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  dcr.io.dcr.ecnt(0).valid := last
  dcr.io.dcr.ecnt(0).bits := cycles

  for (i <- 1 to numRets) {
    dcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
    dcr.io.dcr.ecnt(i).valid := accel.io.out.valid
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs + numDbgs) { i => RegEnable(next = dcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = dcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  /**
   * For now the rule is to first assign the pointers and then assign the vals
   */

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }

  /**
   * Connecting debug ptrs
   */
  for (i <- 0 until numDbgs) {
    debug_module.get.io.addrDebug(i) := dcr.io.dcr.ptrs(numPtrs + i)
  }


  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i))
  }


  accel.io.in.bits.enable := ControlBundle.debug()

  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.flush := state === sFlush

  for (i <- 0 until numDbgs) {
    dmem.io.dme.wr(i + 1).cmd.bits := debug_module.get.io.vmeOut(i).cmd.bits
    dmem.io.dme.wr(i + 1).cmd.valid := debug_module.get.io.vmeOut(i).cmd.valid
    debug_module.get.io.vmeOut(i).cmd.ready := dmem.io.dme.wr(i + 1).cmd.ready

    dmem.io.dme.wr(i + 1).data <> debug_module.get.io.vmeOut(i).data
    debug_module.get.io.vmeOut(i).ack := dmem.io.dme.wr(i + 1).ack
  }

  val dme_ack = if(isDebugger()) Some(RegInit(VecInit(Seq.fill(numDbgs)(false.B)))) else None
  for (i <- 0 until numDbgs) {
    when(dmem.io.dme.wr(i + 1).ack) {
      dme_ack.get(i) := true.B
    }
  }

  def isDMEAck(): Bool = {
    if (numDbgs == 0)
      true.B
    else {
      dme_ack.get.reduceLeft(_ && _)
    }
  }

  val cache_done = RegInit(false.B)
  when(state === sFlush) {
    when(cache.io.cpu.flush_done) {
      cache_done := true.B
    }
  }

  switch(state) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): 0x${Hexadecimal(t._1)}, "))
        printf(p"\nVals: ")
        if (numVals > 0) {
          vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): 0x${Hexadecimal(t._1)}, "))
        } else {
          printf("N/A")
        }
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache_done && isDMEAck()) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  dcr.io.dcr.finish := last

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

}


/**
 *
 * @param accelModule Testing module from dandelion-generator
 * @param numPtrs     Number of input ptrs for the accelerator
 * @param numVals     Number of input values to the accelerator
 * @param numRets     Number of return values to the accelerator
 * @param numEvents   Number of event values to the accelerator
 * @param numCtrls    Number of control registers of the accelerator
 * @param p           implicit parameters that contains all the accelerator configuration
 */
class DandelionDebugFPGAShell(accelModule: () => DandelionAccelDCRModule)
                         (debugModule: () => DandelionAccelDebugModule)
                         (numPtrs: Int, numDbgs: Int, numVals: Int, numRets: Int, numEvents: Int, numCtrls: Int)
                         (implicit val p: Parameters) extends Module with HasAccelParams with HasAccelShellParams {
  val io = IO(new Bundle {
//    val host = new AXIClient(hostParams)
    val host = new ConfigBusMaster(hostParams)
    val mem = new AXIMaster(memParams)
  })

  val regBits = dcrParams.regBits

  /**
   * If xlen is 64bit, and vcr registers are 32bits then
   * ptrs are lo and hi
   */
  val ptrBits =
    if (xlen / regBits == 2)
      regBits * 2
    else
      regBits


//  val dcr = Module(new DCR)
  val dcr = Module(new DCRF1)
  val dmem = Module(new DME())
  val cache = Module(new DMECache())


  val accel = Module(accelModule())
  def isDebugger() = { numDbgs > 0}
  val debug_module = if (numDbgs > 0) Some(Module(debugModule())) else None

  cache.io.cpu.req <> accel.io.MemReq
  accel.io.MemResp <> cache.io.cpu.resp
  cache.io.cpu.abort := false.B

  /**
   * Connecting cache to DME
   */
  dmem.io.dme.rd(0) <> cache.io.mem.rd
  dmem.io.dme.wr(0) <> cache.io.mem.wr

  /**
   * TODO: make enable dependent on logic
   */
  if(isDebugger()) debug_module.get.io.enableNode.foreach(_ := true.B)

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
   * Connecting event controls and return values
   * Event zero always contains the cycle count
   */
  dcr.io.dcr.ecnt(0).valid := last
  dcr.io.dcr.ecnt(0).bits := cycles

  for (i <- 1 to numRets) {
    dcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
    dcr.io.dcr.ecnt(i).valid := accel.io.out.valid
  }

  /**
   * @note This part needs to be changes for each function
   */

  val ptrs = Seq.tabulate(numPtrs + numDbgs) { i => RegEnable(next = dcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }
  val vals = Seq.tabulate(numVals) { i => RegEnable(next = dcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable = (state === sIdle)) }

  /**
   * For now the rule is to first assign the pointers and then assign the vals
   */

  for (i <- 0 until numPtrs) {
    accel.io.in.bits.dataPtrs(s"field${i}") := DataBundle(ptrs(i))
  }

  /**
   * Connecting debug ptrs
   */
  for (i <- 0 until numDbgs) {
    debug_module.get.io.addrDebug(i) := dcr.io.dcr.ptrs(numPtrs + i)
  }


  for (i <- 0 until numVals) {
    accel.io.in.bits.dataVals(s"field${i}") := DataBundle(vals(i))
  }


  accel.io.in.bits.enable := ControlBundle.debug()

  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy

  cache.io.cpu.flush := state === sFlush

  for (i <- 0 until numDbgs) {
    dmem.io.dme.wr(i + 1).cmd.bits := debug_module.get.io.vmeOut(i).cmd.bits
    dmem.io.dme.wr(i + 1).cmd.valid := debug_module.get.io.vmeOut(i).cmd.valid
    debug_module.get.io.vmeOut(i).cmd.ready := dmem.io.dme.wr(i + 1).cmd.ready

    dmem.io.dme.wr(i + 1).data <> debug_module.get.io.vmeOut(i).data
    debug_module.get.io.vmeOut(i).ack := dmem.io.dme.wr(i + 1).ack
  }

  val dme_ack = if(isDebugger()) Some(RegInit(VecInit(Seq.fill(numDbgs)(false.B)))) else None
  for (i <- 0 until numDbgs) {
    when(dmem.io.dme.wr(i + 1).ack) {
      dme_ack.get(i) := true.B
    }
  }

  def isDMEAck(): Bool = {
    if (numDbgs == 0)
      true.B
    else {
      dme_ack.get.reduceLeft(_ && _)
    }
  }

  val cache_done = RegInit(false.B)
  when(state === sFlush) {
    when(cache.io.cpu.flush_done) {
      cache_done := true.B
    }
  }

  switch(state) {
    is(sIdle) {
      when(dcr.io.dcr.launch) {
        printf(p"Ptrs: ")
        ptrs.zipWithIndex.foreach(t => printf(p"ptr(${t._2}): 0x${Hexadecimal(t._1)}, "))
        printf(p"\nVals: ")
        if (numVals > 0) {
          vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): 0x${Hexadecimal(t._1)}, "))
        } else {
          printf("N/A")
        }
        printf(p"\n")
        accel.io.in.valid := true.B
        when(accel.io.in.fire) {
          state := sBusy
        }
      }
    }
    is(sBusy) {
      when(accel.io.out.fire) {
        state := sFlush
      }
    }
    is(sFlush) {
      when(cache_done && isDMEAck()) {
        state := sDone
      }
    }
    is(sDone) {
      state := sIdle
    }
  }


  dcr.io.dcr.finish := last

  io.mem <> dmem.io.mem
  io.host <> dcr.io.host

  //Specific for FPGA
//  io.host.b.bits.id := io.host.w.bits.id
//  io.host.r.bits.id := io.host.ar.bits.id
//
//  io.host.b.bits.user <> DontCare
//  io.host.r.bits.user <> DontCare
//  io.host.r.bits.last := 1.U

}


[0m2021.03.04 00:38:28 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
Mar. 04, 2021 12:38:30 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 583
Mar. 04, 2021 12:39:00 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 603
Mar. 04, 2021 12:39:01 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 605





[0m2021.03.04 00:39:13 INFO  time: code lens generation in 1s[0m









Mar. 04, 2021 12:39:28 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 670

Mar. 04, 2021 12:39:29 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 678

Mar. 04, 2021 12:39:29 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 682
[0m2021.03.04 00:39:29Mar. 04, 2021 12:39:29 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 681
 INFO  time: code lens generation in 1.02s
[0m
Mar. 04, 2021 12:39:29 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 689









Mar. 04, 2021 12:39:41 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 721


Mar. 04, 2021 12:39:44 A.M. org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 731


[0m2021.03.04 00:39:56 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m



[0m2021.03.04 00:40:09 INFO  time: code lens generation in 1.15s[0m
[0m2021.03.04 00:40:24 WARN  no build target for: /run/user/1000/gvfs/sftp:host=server-01/local-scratch/localhome/asedagha/gits/muir-sim/hardware/chisel/src/main/scala/shell/memGenDCRCacheShell.scala[0m
package dandelion.shell

import chisel3._
import chisel3.util._
import chipsalliance.rocketchip.config._
import dandelion.config._
import dandelion.interfaces.{ControlBundle, DataBundle}
import dandelion.interfaces.axi._
import dandelion.memory.cache._
import dandelion.accel._
import memGen.memory._
import memGen.shell._

class memGenDCRCacheShell [T <: memGenModule](accelModule: () => T)
                                             (numPtrs: Int = 0, numVals: Int = 6, numRets: Int = 0, numEvents: Int = 0, numCtrls: Int = 0)
                                             (implicit val p: Parameters) extends Module with HasAccelShellParams {
  val io = IO(new Bundle {
    val host = new AXILiteClient(hostParams)
    val mem = new AXIMaster(memParams)
  })


  val numInputs  = 3
  // comment test

  val regBits = dcrParams.regBits
  val ptrBits = regBits * 2

  val vcr = Module(new DCR)

  val accel = Module(accelModule())

  val sIdle :: sBusy :: sFlush :: sDone :: Nil = Enum(4)

  val state = RegInit(sIdle)
  val cycles = RegInit(0.U(regBits.W))
  val cnt = RegInit(0.U(regBits.W))
  val last = state === sDone
  val is_busy = state === sBusy

  when(state === sIdle) {
    cycles := 0.U
  }.elsewhen(state =/= sFlush) {
    cycles := cycles + 1.U
  }

  /**
    * Connecting event controls and return values
    * Event zero always contains the cycle count
    */
    printf(p"valid a${ccel.io.out.valid}\n" )

  if (accel.RetsOut.size > 0) {
    for (i <- 1 to accel.RetsOut.size) {
      vcr.io.dcr.ecnt(i).bits := accel.io.out.bits.data(s"field${i - 1}").data
      vcr.io.dcr.ecnt(i).valid := accel.io.out.valid
      

    }
  }

 vcr.io.dcr.ecnt(0).valid := last
 vcr.io.dcr.ecnt(0).bits := cycles

  /**
    * @note This part needs to be changes for each function
    */
    val (nextChunk,_) = Counter(accel.io.in.fire, 1000)
    val DataReg = Reg(Vec(numVals, new DataBundle))
    val (cycle,stopSim) = Counter(true.B, 200)

  val vals = Seq.tabulate(numVals) { i => RegEnable(next = vcr.io.dcr.vals(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }
  val ptrs = Seq.tabulate(1) { i => RegEnable(next = vcr.io.dcr.ptrs(i), init = 0.U(ptrBits.W), enable =  (state === sIdle)) }


//  val DataQueue = for (i <- 0 until numInputs) yield {
//    val DQ = Module( new Queue( DataBundle(vals(i-numPtrs)), entries = numVals/numInputs))
//    DQ
//  }

  for (i <- 0 until numVals) {
    if( i % 3 == 1 )
      DataReg(i) := DataBundle(vals(i) + ptrs(0))
    else
     DataReg(i) := DataBundle(vals(i) )
  }

  for (i <- 0 until numInputs) {
    accel.io.in.bits.dataVals(s"field${i}") := DataReg(nextChunk * numInputs.U + i.U)
  }

  accel.io.in.bits.enable := ControlBundle.active()
  accel.io.in.valid := false.B
  accel.io.out.ready := is_busy


  switch(state) {
    is(sIdle) {
      when(vcr.io.dcr.launch) {
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
        state := sBusy
      }
    }
    is(sBusy) {
      when(accel.io.in.fire() ){
        printf(p"\nVals: ")
        vals.zipWithIndex.foreach(t => printf(p"val(${t._2}): ${t._1}, "))
        printf(p"\n")
      }
        accel.io.in.valid := true.B
        when(nextChunk * numInputs.U > numVals.U) {
          state := sDone
        }
    }

    is(sDone) {
      when(stopSim) {
        state := sIdle
      }
    }
  }

  vcr.io.dcr.finish := last & stopSim
  io.mem <> accel.io.mem
  io.host <> vcr.io.host

}


